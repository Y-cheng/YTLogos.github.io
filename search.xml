<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[README]]></title>
    <url>%2F2017%2F08%2F29%2FREADME-MDOWN%2F</url>
    <content type="text"><![CDATA[本博客主要是用来记载我的日常学习笔记，以便于自己学习以及与他人交流 有兴趣的可转至我的博客：logos 联系方式：wechat: yt056410 Email: tyan@zju.edu.cn QQ: 1051927088 GitHub: https://github.com/YTLogos 简书: http://www.jianshu.com/u/bd001545cf0b 博客: https://ytlogos.github.io/ 个人简介：严涛浙江大学作物遗传育种在读研究生（生物信息学方向） 伪码农，R语言爱好者，爱开源]]></content>
  </entry>
  <entry>
    <title><![CDATA[R语言学习笔记之热图绘制]]></title>
    <url>%2F2017%2F08%2F24%2FR%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%83%AD%E5%9B%BE%E7%BB%98%E5%88%B6%2F</url>
    <content type="text"><![CDATA[简介本文将绘制静态与交互式热图，需要使用到以下R包和函数：heatmap():用于绘制简单热图的函数heatmap.2():绘制增强热图的函数d3heatmap:用于绘制交互式热图的R包ComplexHeatmap:用于绘制、注释和排列复杂热图的R&amp;bioconductor包（非常适用于基因组数据分析） 数据准备使用R内置数据集mtcars1df &lt;- as.matrix((scale(mtcars)))#归一化、矩阵化 使用基本函数绘制简单简单热图主要是函数heatmap(x, scale=&quot;row&quot;) x:数据矩阵 scale：表示不同方向，可选值有：row, columa, none Default plotheatmap(df, scale = “none”)123Use custom colorscol &lt;- colorRampPalette(c(&quot;red&quot;, &quot;white&quot;, &quot;blue&quot;))(256)heatmap(df, scale = &quot;none&quot;, col=col) 123#Use RColorBrewer color palette nameslibrary(RColorBrewer)col &lt;- colorRampPalette(brewer.pal(10, &quot;RdYlBu&quot;))(256)#自设置调色板dim(df)#查看行列数## [1] 32 11 123heatmap(df, scale = &quot;none&quot;, col=col, RowSideColors = rep(c(&quot;blue&quot;, &quot;pink&quot;), each=16), ColSideColors = c(rep(&quot;purple&quot;, 5), rep(&quot;orange&quot;, 6)))#参数RowSideColors和ColSideColors用于分别注释行和列颜色等,可help(heatmap)详情 增强热图函数heatmap.2()在热图绘制方面提供许多扩展，此函数包装在gplots包里。12library(gplots)heatmap.2(df, scale = &quot;none&quot;, col=bluered(100), trace = &quot;none&quot;, density.info = &quot;none&quot;)#还有其他参数可参考help(heatmap.2()) 交互式热图绘制d3heatmap包可用于生成交互式热图绘制,可通过以下代码生成：123if (!require(&quot;devtools&quot;)) install.packages(&quot;devtools&quot;) devtools::install_github(&quot;rstudio/d3heatmap&quot;) 函数d3heatmap()用于创建交互式热图，有以下功能： 将鼠标放在感兴趣热图单元格上以查看行列名称及相应值 可选择区域进行缩放1library(d3heatmap)d3heatmap(df, colors = &quot;RdBu&quot;, k_row = 4, k_col = 2) k_row、k_col分别指定用于对行列中树形图分支进行着色所需组数。进一步信息可help(d3heatmap())获取。 使用dendextend包增强热图软件包dendextend可以用于增强其他软件包的功能123456789101112library(dendextend)# order for rowsRowv &lt;- mtcars %&gt;% scale %&gt;% dist %&gt;% hclust %&gt;% as.dendrogram %&gt;% set(&quot;branches_k_color&quot;, k = 3) %&gt;% set(&quot;branches_lwd&quot;, 1.2) %&gt;% ladderize# Order for columns# We must transpose the dataColv &lt;- mtcars %&gt;% scale %&gt;% t %&gt;% dist %&gt;% hclust %&gt;% as.dendrogram %&gt;% set(&quot;branches_k_color&quot;, k = 2, value = c(&quot;orange&quot;, &quot;blue&quot;)) %&gt;% set(&quot;branches_lwd&quot;, 1.2) %&gt;% ladderize增强heatmap()函数---heatmap(df, Rowv = Rowv, Colv = Colv, scale = &quot;none&quot;) 12#增强heatmap.2()函数heatmap.2(df, scale = &quot;none&quot;, col = bluered(100), Rowv = Rowv, Colv = Colv, trace = &quot;none&quot;, density.info = &quot;none&quot;) 12#增强交互式绘图函数d2heatmap()d3heatmap(scale(mtcars), colors = &quot;RdBu&quot;, Rowv = Rowv, Colv = Colv) 绘制复杂热图ComplexHeatmap包是bioconductor包，用于绘制复杂热图，它提供了一个灵活的解决方案来安排和注释多个热图。它还允许可视化来自不同来源的不同数据之间的关联热图。可通过以下代码安装：12if (!require(&quot;devtools&quot;)) install.packages(&quot;devtools&quot;) devtools::install_github(&quot;jokergoo/ComplexHeatmap&quot;) ComplexHeatmap包的主要功能函数是Heatmap(),格式为：Heatmap(matrix, col, name) matrix：矩阵 col：颜色向量（离散色彩映射）或颜色映射函数（如果矩阵是连续数） name：热图名称12library(ComplexHeatmap)Heatmap(df, name = &quot;mtcars&quot;) 123#自设置颜色library(circlize)Heatmap(df, name = &quot;mtcars&quot;, col = colorRamp2(c(-2, 0, 2), c(&quot;green&quot;, &quot;white&quot;, &quot;red&quot;))) 使用调色板1Heatmap(df, name = &quot;mtcars&quot;,col = colorRamp2(c(-2, 0, 2), brewer.pal(n=3, name=&quot;RdBu&quot;))) 12#自定义颜色mycol &lt;- colorRamp2(c(-2, 0, 2), c(&quot;blue&quot;, &quot;white&quot;, &quot;red&quot;)) #热图及行列标题设置12Heatmap(df, name = &quot;mtcars&quot;, col = mycol, column_title = &quot;Column title&quot;, row_title = &quot;Row title&quot;) 注意，行标题的默认位置是“left”，列标题的默认是“top”。可以使用以下选项更改： row_title_side：允许的值为“左”或“右”（例如：row_title_side =“right”） column_title_side：允许的值为“top”或“bottom”（例如：column_title_side =“bottom”） 也可以使用以下选项修改字体和大小： row_title_gp：用于绘制行文本的图形参数 column_title_gp：用于绘制列文本的图形参数123Heatmap(df, name = &quot;mtcars&quot;, col = mycol, column_title = &quot;Column title&quot;, column_title_gp = gpar(fontsize = 14, fontface = &quot;bold&quot;), row_title = &quot;Row title&quot;, row_title_gp = gpar(fontsize = 14, fontface = &quot;bold&quot;)) 在上面的R代码中，fontface的可能值可以是整数或字符串：1 = plain，2 = bold，3 =斜体，4 =粗体斜体。如果是字符串，则有效值为：“plain”，“bold”，“italic”，“oblique”和“bold.italic”。显示行/列名称： show_row_names：是否显示行名称。默认值为TRUE show_column_names：是否显示列名称。默认值为TRUE 1Heatmap(df, name = &quot;mtcars&quot;, show_row_names = FALSE) 更改聚类外观默认情况下，行和列是包含在聚类里的。可以使用参数修改： cluster_rows = FALSE。如果为TRUE，则在行上创建集群 cluster_columns = FALSE。如果为TRUE，则将列置于簇上12# Inactivate cluster on rowsHeatmap(df, name = &quot;mtcars&quot;, col = mycol, cluster_rows = FALSE) 如果要更改列集群的高度或宽度，可以使用选项column_dend_height和row_dend_width：12Heatmap(df, name = &quot;mtcars&quot;, col = mycol, column_dend_height = unit(2, &quot;cm&quot;), row_dend_width = unit(2, &quot;cm&quot;) ) 我们还可以利用color_branches()自定义树状图外观12345library(dendextend)row_dend = hclust(dist(df)) # row clusteringcol_dend = hclust(dist(t(df))) # column clusteringHeatmap(df, name = &quot;mtcars&quot;, col = mycol, cluster_rows = color_branches(row_dend, k = 4), cluster_columns = color_branches(col_dend, k = 2)) 不同的聚类距离计算方式参数clustering_distance_rows和clustering_distance_columns用于分别指定行和列聚类的度量标准，允许的值有“euclidean”, “maximum”, “manhattan”, “canberra”, “binary”, “minkowski”, “pearson”, “spearman”, “kendall”。12Heatmap(df, name = &quot;mtcars&quot;, clustering_distance_rows = &quot;pearson&quot;, clustering_distance_columns = &quot;pearson&quot;) 12#也可以自定义距离计算方式Heatmap(df, name = &quot;mtcars&quot;, clustering_distance_rows = function(m) dist(m)) 1Heatmap(df, name = &quot;mtcars&quot;, clustering_distance_rows = function(x, y) 1 - cor(x, y)) 请注意，在上面的R代码中，通常为指定行聚类的度量的参数 clustering_distance_rows显示示例。建议对参数clustering_distance_columns（列聚类的度量标准）使用相同的度量标准。 12345678# Clustering metric functionrobust_dist = function(x, y) &#123; qx = quantile(x, c(0.1, 0.9)) qy = quantile(y, c(0.1, 0.9)) l = x &gt; qx[1] &amp; x &lt; qx[2] &amp; y &gt; qy[1] &amp; y &lt; qy[2] x = x[l] y = y[l] sqrt(sum((x - y)^2))&#125;# HeatmapHeatmap(df, name = &quot;mtcars&quot;, clustering_distance_rows = robust_dist, clustering_distance_columns = robust_dist, col = colorRamp2(c(-2, 0, 2), c(&quot;purple&quot;, &quot;white&quot;, &quot;orange&quot;))) 聚类方法参数clustering_method_rows和clustering_method_columns可用于指定进行层次聚类的方法。允许的值是hclust()函数支持的值，包括“ward.D”，“ward.D2”，“single”，“complete”，“average”，…（见?hclust）。12Heatmap(df, name = &quot;mtcars&quot;, clustering_method_rows = &quot;ward.D&quot;, clustering_method_columns = &quot;ward.D&quot;) 热图拆分有很多方法来拆分热图。一个解决方案是应用k-means使用参数km。在执行k-means时使用set.seed()函数很重要，这样可以在稍后精确地再现结果12set.seed(1122)# split into 2 groupsHeatmap(df, name = &quot;mtcars&quot;, col = mycol, k = 2) 12# split by a vector specifying row classes， 有点类似于ggplot2里的分面Heatmap(df, name = &quot;mtcars&quot;, col = mycol, split = mtcars$cyl ) 123#split也可以是一个数据框，其中不同级别的组合拆分热图的行。# Split by combining multiple variablesHeatmap(df, name =&quot;mtcars&quot;, col = mycol, split = data.frame(cyl = mtcars$cyl, am = mtcars$am)) 12# Combine km and splitHeatmap(df, name =&quot;mtcars&quot;, col = mycol, km = 2, split = mtcars$cyl) 12345#也可以自定义分割library(&quot;cluster&quot;)set.seed(1122)pa = pam(df, k = 3)Heatmap(df, name = &quot;mtcars&quot;, col = mycol, split = paste0(&quot;pam&quot;, pa$clustering)) 还可以将用户定义的树形图和分割相结合。在这种情况下，split可以指定为单个数字： 123row_dend = hclust(dist(df)) # row clusteringrow_dend = color_branches(row_dend, k = 4)Heatmap(df, name = &quot;mtcars&quot;, col = mycol, cluster_rows = row_dend, split = 2) 热图注释利用HeatmapAnnotation()对行或列注释。格式为： HeatmapAnnotation(df, name, col, show_legend) df：带有列名的data.frame name：热图标注的名称 col：映射到df中列的颜色列表123# Transposedf &lt;- t(df)# Heatmap of the transposed dataHeatmap(df, name =&quot;mtcars&quot;, col = mycol) 12345678910# Annotation data frameannot_df &lt;- data.frame(cyl = mtcars$cyl, am = mtcars$am, mpg = mtcars$mpg)# Define colors for each levels of qualitative variables# Define gradient color for continuous variable (mpg)col = list(cyl = c(&quot;4&quot; = &quot;green&quot;, &quot;6&quot; = &quot;gray&quot;, &quot;8&quot; = &quot;darkred&quot;), am = c(&quot;0&quot; = &quot;yellow&quot;, &quot;1&quot; = &quot;orange&quot;), mpg = colorRamp2(c(17, 25), c(&quot;lightblue&quot;, &quot;purple&quot;)) )# Create the heatmap annotationha &lt;- HeatmapAnnotation(annot_df, col = col)# Combine the heatmap and the annotationHeatmap(df, name = &quot;mtcars&quot;, col = mycol, top_annotation = ha) 123#可以使用参数show_legend = FALSE来隐藏注释图例ha &lt;- HeatmapAnnotation(annot_df, col = col, show_legend = FALSE)Heatmap(df, name = &quot;mtcars&quot;, col = mycol, top_annotation = ha) 12345678910111213#注释名称可以使用下面的R代码添加library(&quot;GetoptLong&quot;)# Combine Heatmap and annotationha &lt;- HeatmapAnnotation(annot_df, col = col, show_legend = FALSE)Heatmap(df, name = &quot;mtcars&quot;, col = mycol, top_annotation = ha)# Add annotation names on the rightfor(an in colnames(annot_df)) &#123; seekViewport(qq(&quot;annotation_@&#123;an&#125;&quot;)) grid.text(an, unit(1, &quot;npc&quot;) + unit(2, &quot;mm&quot;), 0.5, default.units = &quot;npc&quot;, just = &quot;left&quot;)&#125;#要在左侧添加注释名称，请使用以下代码# Annotation names on the leftfor(an in colnames(annot_df)) &#123; seekViewport(qq(&quot;annotation_@&#123;an&#125;&quot;)) grid.text(an, unit(1, &quot;npc&quot;) - unit(2, &quot;mm&quot;), 0.5, default.units = &quot;npc&quot;, just = &quot;left&quot;)&#125; 复杂注释将热图与一些基本图形结合起来进行注释，利用anno_point(),anno_barplot(),anno_boxplot(),anno_density()和anno_histogram()。123456789101112# Define some graphics to display the distribution of columns.hist = anno_histogram(df, gp = gpar(fill = &quot;lightblue&quot;)).density = anno_density(df, type = &quot;line&quot;, gp = gpar(col = &quot;blue&quot;))ha_mix_top = HeatmapAnnotation(hist = .hist, density = .density)# Define some graphics to display the distribution of rows.violin = anno_density(df, type = &quot;violin&quot;, gp = gpar(fill = &quot;lightblue&quot;), which = &quot;row&quot;).boxplot = anno_boxplot(df, which = &quot;row&quot;)ha_mix_right = HeatmapAnnotation(violin = .violin, bxplt = .boxplot, which = &quot;row&quot;, width = unit(4, &quot;cm&quot;))# Combine annotation with heatmapHeatmap(df, name = &quot;mtcars&quot;, col = mycol, column_names_gp = gpar(fontsize = 8), top_annotation = ha_mix_top, top_annotation_height = unit(4, &quot;cm&quot;)) + ha_mix_right 热图组合123456# Heatmap 1ht1 = Heatmap(df, name = &quot;ht1&quot;, col = mycol, km = 2, column_names_gp = gpar(fontsize = 9))# Heatmap 2ht2 = Heatmap(df, name = &quot;ht2&quot;, col = colorRamp2(c(-2, 0, 2), c(&quot;green&quot;, &quot;white&quot;, &quot;red&quot;)), column_names_gp = gpar(fontsize = 9))# Combine the two heatmapsht1 + ht2 可以使用选项width = unit（3，“cm”））来控制热图大小。注意，当组合多个热图时，第一个热图被视为主热图。剩余热图的一些设置根据主热图的设置自动调整。这些设置包括：删除行集群和标题，以及添加拆分等。 12345678draw(ht1 + ht2, # Titles row_title = &quot;Two heatmaps, row title&quot;, row_title_gp = gpar(col = &quot;red&quot;), column_title = &quot;Two heatmaps, column title&quot;, column_title_side = &quot;bottom&quot;, # Gap between heatmaps gap = unit(0.5, &quot;cm&quot;)) 可以使用参数show_heatmap_legend = FALSE，show_annotation_legend = FALSE删除图例。 #基因表达矩阵在基因表达数据中，行代表基因，列是样品值。关于基因的更多信息可以在表达热图之后附加，例如基因长度和基因类型。123456789expr = readRDS(paste0(system.file(package = &quot;ComplexHeatmap&quot;), &quot;/extdata/gene_expression.rds&quot;))mat = as.matrix(expr[, grep(&quot;cell&quot;, colnames(expr))])type = gsub(&quot;s\\d+_&quot;, &quot;&quot;, colnames(mat))ha = HeatmapAnnotation(df = data.frame(type = type))Heatmap(mat, name = &quot;expression&quot;, km = 5, top_annotation = ha, top_annotation_height = unit(4, &quot;mm&quot;), show_row_names = FALSE, show_column_names = FALSE) +Heatmap(expr$length, name = &quot;length&quot;, width = unit(5, &quot;mm&quot;), col = colorRamp2(c(0, 100000), c(&quot;white&quot;, &quot;orange&quot;))) +Heatmap(expr$type, name = &quot;type&quot;, width = unit(5, &quot;mm&quot;)) +Heatmap(expr$chr, name = &quot;chr&quot;, width = unit(5, &quot;mm&quot;), col = rand_color(length(unique(expr$chr)))) 也可以可视化基因组变化和整合不同的分子水平（基因表达，DNA甲基化，…） 可视化矩阵中列的分布使用函数densityHeatmap().1densityHeatmap(df) Infos1234567891011121314151617181920212223242526272829303132333435363738sessionInfo()## R version 3.3.3 (2017-03-06)## Platform: x86_64-w64-mingw32/x64 (64-bit)## Running under: Windows 8.1 x64 (build 9600)## ## locale:## [1] LC_COLLATE=Chinese (Simplified)_China.936 ## [2] LC_CTYPE=Chinese (Simplified)_China.936 ## [3] LC_MONETARY=Chinese (Simplified)_China.936## [4] LC_NUMERIC=C ## [5] LC_TIME=Chinese (Simplified)_China.936 ## ## attached base packages:## [1] grid stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages:## [1] GetoptLong_0.1.6 cluster_2.0.5 circlize_0.3.10 ## [4] ComplexHeatmap_1.12.0 dendextend_1.4.0 d3heatmap_0.6.1.1##[7] gplots_3.0.1 RColorBrewer_1.1-2 ## ## loaded via a namespace (and not attached):## [1] Rcpp_0.12.9 DEoptimR_1.0-8 plyr_1.8.4 ## [4] viridis_0.3.4 class_7.3-14 prabclus_2.2-6 ## [7] bitops_1.0-6 base64enc_0.1-3 tools_3.3.3 ## [10] digest_0.6.12 mclust_5.2.2 jsonlite_1.3 ## [13] evaluate_0.10 tibble_1.2 gtable_0.2.0 ## [16] lattice_0.20-34 png_0.1-7 yaml_2.1.14 ## [19] mvtnorm_1.0-6 gridExtra_2.2.1 trimcluster_0.1-2 ## [22] stringr_1.2.0 knitr_1.15.1 GlobalOptions_0.0.11## [25] htmlwidgets_0.8 gtools_3.5.0 caTools_1.17.1 ## [28] fpc_2.1-10 diptest_0.75-7 nnet_7.3-12 ## [31] stats4_3.3.3 rprojroot_1.2 robustbase_0.92-7 ## [34] flexmix_2.3-13 rmarkdown_1.3.9002 gdata_2.17.0 ## [37] kernlab_0.9-25 ggplot2_2.2.1 magrittr_1.5 ## [40] whisker_0.3-2 backports_1.0.5 scales_0.4.1 ## [43] htmltools_0.3.5 modeltools_0.2-21 MASS_7.3-45## [46] assertthat_0.1 shape_1.4.2 colorspace_1.3-2 ## [49] KernSmooth_2.23-15 stringi_1.1.2 lazyeval_0.2.0 ## [52] munsell_0.4.3 rjson_0.2.15 联系方式：wechat: yt056410Email: tyan@zju.edu.cnQQ: 1051927088GitHub: https://github.com/YTLogos简书: http://www.jianshu.com/u/bd001545cf0b博客: https://ytlogos.github.io/ 个人简介：严涛浙江大学作物遗传育种在读研究生（生物信息学方向）伪码农，R语言爱好者，爱开源]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>R&amp;Heatmap&amp;visualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R语言可视化学习笔记之基因组数据可视化]]></title>
    <url>%2F2017%2F08%2F24%2FR%E8%AF%AD%E8%A8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E5%9B%A0%E7%BB%84%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%2F</url>
    <content type="text"><![CDATA[本文主要利用ggpubr包来探索基因组数据,主要是可视化TCGA基因组数据的基因表达谱。1library(ggpubr)#加载包 TCGA是一个包含大量癌症数据的数据库，由Marcin Kosinski创建的RTCGA包可以让我们很方便的获取这些数据。主要有三个包：RTCGA、RTCGA.clininal、RTCGA.mRNA。安装方法如下：1234567#Load the bioconductor installersource(&quot;http://bioconductor.org/biocLite.R&quot;&quot;)#设置镜像，这里我们选择中科大的镜像options(BioC_mirror=&quot;http://ustc.edu.cn/bioc&quot;)#下载包biocLite(&quot;RTCGA&quot;)biocLite(&quot;RTCGA.clininal&quot;)biocLite(&quot;RTCGA.mRNA&quot;) 123library(RTCGA)#查看每一种癌症的数据集infoTCGA() RTCGA包里的函数expressionTCGA()可以十分方便地从不同数据集中提取基因的表达值，下面我们将从三个数据集BRCA(乳腺癌)、OV(卵巢癌)、LUSC(肺癌)中提取五个基因的表达值。12345library(RTCGA)library(RTCGA.mRNA)expr &lt;- expressionsTCGA(BRCA.mRNA, OV.mRNA, LUSC.mRNA, extract.cols = c(&quot;GATA3&quot;, &quot;PTEN&quot;, &quot;XBP1&quot;, &quot;ESR1&quot;, &quot;MUC1&quot;))expr 查看每个数据集中的样品数量12345nb_samples &lt;- table(expr$dataset)nb_samples## ## BRCA.mRNA LUSC.mRNA OV.mRNA ## 590 154 561 为了方便，我们将部分数据集名称简化123expr$dataset &lt;- gsub(pattern = &quot;.mRNA&quot;, replacement = &quot;&quot;, expr$dataset)expr$bcr_patient_barcode &lt;- paste0(expr$dataset, c(1:590, 1:561, 1:154))expr 接下来绘制图形：1、箱线图123library(ggpubr)ggboxplot(expr, x=&quot;dataset&quot;, y=&quot;GATA3&quot;, title=&quot;GATA3&quot;, ylab = &quot;Expression&quot;, color = &quot;dataset&quot;, palette = &quot;jco&quot;) 我们可以一次性绘制多个基因，然后一一查看，而不用每次写代码：123456#Creat a list of plotsp &lt;- ggboxplot(expr, x=&quot;dataset&quot;, y=c(&quot;GATA3&quot;, &quot;PTEN&quot;, &quot;XBP1&quot;, &quot;ESR1&quot;, &quot;MUC1&quot;),title = c(&quot;GATA3&quot;, &quot;PTEN&quot;, &quot;XBP1&quot;, &quot;ESR1&quot;, &quot;MUC1&quot;), ylab = &quot;EXpression&quot;, color = &quot;dataset&quot;, palette = &quot;jco&quot;)#接下来一一查看每个plotp$GATA3 1p$PTEN 1p$XBP1 1p$ESR1 1p$MUC1 当一次性绘制多个基因时，xlab,ylab,title也可以是一个跟y等长的向量。 接下来就是添加p-value以及显著性了123my_comparisons &lt;- list(c(&quot;BRCA&quot;, &quot;OV&quot;), c(&quot;OV&quot;, &quot;LUSC&quot;))ggboxplot(expr, x=&quot;dataset&quot;, y=&quot;GATA3&quot;, title = &quot;GATA3&quot;, ylab = &quot;Expression&quot;, color = &quot;dataset&quot;, palette = &quot;jco&quot;)+ stat_compare_means(comparisons = my_comparisons) 也可以查看每个类型中每一个基因的比较：1compare_means(c(GATA3, PTEN, XBP1)~dataset, data = expr) 可以通过select以及remove来决定比较那几个类型，比如这里我们只比较BRCA和OV12ggboxplot(expr, x=&quot;dataset&quot;, y=&quot;GATA3&quot;, title = &quot;GATA3&quot;, ylab = &quot;Expression&quot;, color = &quot;dataset&quot;, palette = &quot;jco&quot;, select = c(&quot;BRCA&quot;, &quot;OV&quot;))#通过select选择 12ggboxplot(expr, x=&quot;dataset&quot;, y=&quot;GATA3&quot;, title = &quot;GATA3&quot;, ylab = &quot;Expression&quot;, color = &quot;dataset&quot;, palette = &quot;jco&quot;, remove = &quot;BRCA&quot;)#通过remove选择 通过order来改变各类型在x轴上的顺序12ggboxplot(expr, x=&quot;dataset&quot;, y=&quot;GATA3&quot;, title = &quot;GATA3&quot;, ylab = &quot;Expression&quot;, color = &quot;dataset&quot;, palette = &quot;jco&quot;, order = c(&quot;LUSC&quot;, &quot;OV&quot;, &quot;BRCA&quot;)) 通过rotate=TRUE来变换坐标轴12ggboxplot(expr, x=&quot;dataset&quot;, y=&quot;GATA3&quot;, title = &quot;GATA3&quot;, ylab = &quot;Expression&quot;, color = &quot;dataset&quot;, palette = &quot;jco&quot;, rotate=TRUE) 通过combine=TRUE来进行分面（类似于facet）12ggboxplot(expr, x=&quot;dataset&quot;, y=c(&quot;GATA3&quot;, &quot;PTEN&quot;, &quot;XBP1&quot;), ylab = &quot;Expression&quot;, color = &quot;dataset&quot;, palette = &quot;jco&quot;, combine = TRUE) 通过merge=TRUE或者merge=“axis”将三个类型的plot绘制在一个panel中12ggboxplot(expr, x=&quot;dataset&quot;, y=c(&quot;GATA3&quot;, &quot;PTEN&quot;, &quot;XBP1&quot;), ylab = &quot;Expression&quot;,color = &quot;dataset&quot;, palette = &quot;jco&quot;, merge = TRUE) 通过merge=flip利用不同癌症类型进行group12ggboxplot(expr, x=&quot;dataset&quot;, y=c(&quot;GATA3&quot;, &quot;PTEN&quot;, &quot;XBP1&quot;), ylab = &quot;Expression&quot;, palette = &quot;jco&quot;, merge = &quot;flip&quot;) 通过add=jitter增加抖动点123ggboxplot(expr, x=&quot;dataset&quot;, y=c(&quot;GATA3&quot;, &quot;PTEN&quot;, &quot;XBP1&quot;), combine = TRUE,color = &quot;dataset&quot;, palette = &quot;jco&quot;, ylab = &quot;Expression&quot;, add = &quot;jitter&quot;, add.params = list(size=0.1, jitter=0.2)) 通过add=dotplot增加dotplot123ggboxplot(expr, x=&quot;dataset&quot;, y=c(&quot;GATA3&quot;, &quot;PTEN&quot;, &quot;XBP1&quot;), combine = TRUE, color = &quot;dataset&quot;, palette = &quot;jco&quot;, ylab = &quot;Expression&quot;, add = &quot;dotplot&quot;, add.params = list(binwidth=0.1, dotsize=0.2)) 很多时候我们很像知道箱线图两端的数据，我们可以通过label来进行展示12345ggboxplot(expr, x=&quot;dataset&quot;, y=c(&quot;GATA3&quot;, &quot;PTEN&quot;, &quot;XBP1&quot;), combine = TRUE,color = &quot;dataset&quot;, palette = &quot;jco&quot;, ylab = &quot;Expression&quot;, add = &quot;jitter&quot;, add.params = list(size=0.1, jitter=0.2), label = &quot;bcr_patient_barcode&quot;, label.select = list(top.up=2, top.down=2), font.label = list(size=9, face=&quot;italic&quot;), repel = TRUE) 2、小提琴图12ggviolin(expr,x=&quot;dataset&quot;, y=c(&quot;GATA3&quot;, &quot;PTEN&quot;, &quot;XBP1&quot;), combine = TRUE, color = &quot;dataset&quot;, palette = &quot;jco&quot;, ylab = &quot;Expression&quot;, add = &quot;boxplot&quot;) 通过修改add来更改添加小提琴图里的图形12ggviolin(expr,x=&quot;dataset&quot;, y=c(&quot;GATA3&quot;, &quot;PTEN&quot;, &quot;XBP1&quot;), combine = TRUE, color = &quot;dataset&quot;, palette = &quot;jco&quot;, ylab = &quot;Expression&quot;, add = &quot;median_iqr&quot;) add有好多选项可以选择：“mean”, “mean_se”, “mean_sd”, “mean_ci”, “mean_range”, “median”, “median_iqr”, “median_mad”, “median_range”.有兴趣的可以自己试试。 3、带状图123ggstripchart(expr, x=&quot;dataset&quot;, y=c(&quot;GATA3&quot;, &quot;PTEN&quot;, &quot;XBP1&quot;), combine = TRUE,color = &quot;dataset&quot;, palette = &quot;jco&quot;, size = 0.1, jitter=0.2, ylab = &quot;Expression&quot;, add = &quot;median_iqr&quot;, add.params = list(color=&quot;red&quot;)) 4、dotplot123ggdotplot(expr, x=&quot;dataset&quot;, y=c(&quot;GATA3&quot;, &quot;PTEN&quot;, &quot;XBP1&quot;), combine = TRUE, color = &quot;dataset&quot;, palette = &quot;jco&quot;, fill = &quot;white&quot;, binwidth = 0.1, ylab = &quot;Expression&quot;,add = &quot;median_iqr&quot;, add.params = list(size=0.9)) 5、密度图12ggdensity(expr, x=c(&quot;GATA3&quot;, &quot;PTEN&quot;, &quot;XBP1&quot;), y=&quot;..density..&quot;, combine = TRUE, xlab = &quot;Expression&quot;, add = &quot;median&quot;, rug = TRUE) 将dataset映射给颜色123ggdensity(expr, x=c(&quot;GATA3&quot;, &quot;PTEN&quot;, &quot;XBP1&quot;), y=&quot;..density..&quot;, combine = TRUE,xlab = &quot;Expression&quot;, add = &quot;median&quot;, rug = TRUE, color = &quot;dataset&quot;, fill = &quot;dataset&quot;, palette = &quot;jco&quot;) 将三幅图整合进一个panel中，并对y轴进行..count..，而不是..density..123ggdensity(expr, x=c(&quot;GATA3&quot;, &quot;PTEN&quot;, &quot;XBP1&quot;), y=&quot;..count..&quot;, xlab = &quot;Expression&quot;,add = &quot;median&quot;, rug = TRUE, palette = &quot;jco&quot;)## $GATA3 1## ## $PTEN 1## ## $XBP1 颜色映射，将x轴变量映射给颜色12ggdensity(expr, x=c(&quot;GATA3&quot;, &quot;PTEN&quot;, &quot;XBP1&quot;), y=&quot;..count..&quot;, color = &quot;.x.&quot;, fill = &quot;.x.&quot;, merge = TRUE, xlab = &quot;Expression&quot;, add = &quot;median&quot;, rug = TRUE, palette = &quot;jco&quot;) 按dataset进行分面123ggdensity(expr, x=c(&quot;GATA3&quot;, &quot;PTEN&quot;, &quot;XBP1&quot;), y=&quot;..count..&quot;, color = &quot;.x.&quot;, fill = &quot;.x.&quot;, merge = TRUE, xlab = &quot;Expression&quot;, add = &quot;median&quot;, rug = TRUE, palette = &quot;jco&quot;, facet.by = &quot;dataset&quot;) 6、直方图123gghistogram(expr, x=c(&quot;GATA3&quot;, &quot;PTEN&quot;, &quot;XBP1&quot;), y=&quot;..density..&quot;, xlab = &quot;Expression&quot;, add = &quot;median&quot;, rug = TRUE)## $GATA3 1## ## $PTEN 1## ## $XBP1 将dataset映射给颜色123gghistogram(expr, x=c(&quot;GATA3&quot;, &quot;PTEN&quot;, &quot;XBP1&quot;), y=&quot;..density..&quot;, xlab = &quot;Expression&quot;, add = &quot;median&quot;, rug = TRUE, color = &quot;dataset&quot;, fill = &quot;dataset&quot;, palette = &quot;jco&quot;)## $GATA3 1## ## $PTEN 1## ## $XBP1 后面还有一些将几幅图整合在一个panel以及分面等大同小异就不讲了。7、Q-Q图1ggqqplot(expr, x=c(&quot;GATA3&quot;, &quot;PTEN&quot;, &quot;XBP1&quot;), combine = TRUE, size = 0.5) 颜色映射12ggqqplot(expr, x=c(&quot;GATA3&quot;, &quot;PTEN&quot;, &quot;XBP1&quot;), combine = TRUE, size = 0.5, color = &quot;dataset&quot;, palette = &quot;jco&quot;) #sessionInfo123456789101112131415161718192021222324252627282930313233343536373839404142434445sessionInfo()## R version 3.4.0 (2017-04-21)## Platform: x86_64-pc-linux-gnu (64-bit)## Running under: Ubuntu 16.04.2 LTS## ## Matrix products: default## BLAS: /usr/lib/libblas/libblas.so.3.6.0## LAPACK: /usr/lib/lapack/liblapack.so.3.6.0## ## locale:## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=zh_CN.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=zh_CN.UTF-8 LC_MESSAGES=en_US.UTF-8## [7] LC_PAPER=zh_CN.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=zh_CN.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages:## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages:## [1] bindrcpp_0.2 RTCGA.mRNA_1.4.0 RTCGA_1.6.0 ggpubr_0.1.3 ## [5] magrittr_1.5 ggplot2_2.2.1 ## ## loaded via a namespace (and not attached):## [1] zoo_1.8-0 reshape2_1.4.2 purrr_0.2.2.2 ## [4] splines_3.4.0 ggthemes_3.4.0 lattice_0.20-35 ## [7] colorspace_1.3-2 htmltools_0.3.6 viridisLite_0.2.0## [10] yaml_2.1.14 survival_2.41-3 XML_3.98-1.9 ## [13] survMisc_0.5.4 rlang_0.1.1 foreign_0.8-68 ## [16] glue_1.1.0 bindr_0.1 plyr_1.8.4 ## [19] stringr_1.2.0 ggsignif_0.2.0 munsell_0.4.3 ## [22] gtable_0.2.0 ggsci_2.7 rvest_0.3.2 ## [25] psych_1.7.5 evaluate_0.10 labeling_0.3 ## [28] knitr_1.16 parallel_3.4.0 broom_0.4.2 ## [31] Rcpp_0.12.11 xtable_1.8-2 scales_0.4.1## [34] backports_1.1.0 cmprsk_2.2-7 km.ci_0.5-2 ## [37] gridExtra_2.2.1 mnormt_1.5-5 digest_0.6.12 ## [40] stringi_1.1.5 ggrepel_0.6.5 dplyr_0.7.0 ## [43] KMsurv_0.1-5 grid_3.4.0 rprojroot_1.2 ## [46] tools_3.4.0 lazyeval_0.2.0 tibble_1.3.3 ## [49] tidyr_0.6.3 Matrix_1.2-10 data.table_1.10.4## [52] xml2_1.1.1 survminer_0.4.0 assertthat_0.2.0 ## [55] rmarkdown_1.6 httr_1.2.1 viridis_0.4.0 ## [58] R6_2.2.2 nlme_3.1-131 compiler_3.4.0 联系方式：wechat: yt056410Email: tyan@zju.edu.cnQQ: 1051927088GitHub: https://github.com/YTLogos简书: http://www.jianshu.com/u/bd001545cf0b博客: https://ytlogos.github.io/ 个人简介：严涛浙江大学作物遗传育种在读研究生（生物信息学方向）伪码农，R语言爱好者，爱开源]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>R&amp;ggpubr&amp;visualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ggplot2学习笔记系列之利用ggplot2绘制散点图]]></title>
    <url>%2F2017%2F08%2F24%2Fggplot2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%A9%E7%94%A8ggplot2%E7%BB%98%E5%88%B6%E6%95%A3%E7%82%B9%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[1 简介散点图通常用来刻画两个连续型变量之间的关系。绘制散点图时数据集中的每一个观测值都由散点图中的一个点来表示。利用包ggplot2可以绘制十分漂亮的散点图。 利用ggplot2绘图前先确保我们所使用的数据集是data.frame形式。ggplot2绘图利用映射将数据赋予给坐标轴上进而添加几何对象形成图形。绘图前先加载包ggplot2 即library(ggplot2)。12#Load packageslibrary(ggplot2)#visualization 加载完包之后，本文利用数据集mtcars来演示散点图绘制。 先查看数据集的前几行来了解mtcars数据集。12#check datahead(mtcars) 2 绘制简单的散点图1ggplot(data=mtcars, aes(x=wt, y=mpg)) + geom_point() 2.1 shape参数修改图形的形状 可选点图形形状:1ggplot(data=mtcars, aes(x=wt, y=mpg)) +geom_point(shape=17) 2.2 size参数修改点的大小1ggplot(data = mtcars, aes(x=wt, y=mpg))+geom_point(size=5) 2.3 color参数修改点的颜色1ggplot(data=mtcars, aes(x=wt, y=mpg))+geom_point(color=&quot;red&quot;) 3 绘制分组的散点图可将分组变量（因子或字符变量，可通过factor()强制性将非因子变量转为因子变量）赋值给颜色或性状属性，实现分组散点图的绘制。3.1 首先将数值型变量cyl转换为因子型变量1mtcars$cyl &lt;- factor(mtcars$cyl) 3.2 分组变量赋值给颜色属性(变量赋值必须在aes里面)1ggplot(data=mtcars, aes(x=wt, y=mpg, color=cyl))+geom_point(size=3) 3.3 分组变量赋值给性状属性1ggplot(data=mtcars, aes(x=wt, y=mpg, shape=cyl))+geom_point(size=3) 如果对R语言默认的颜色或者形状不满意，可以通过scale_color_brewer()或者scale_color_manual()函数自定义点的颜色以及scale_shape_manual()函数自定义点的形状。 下面我们将分组变量cyl同时赋值给颜色和形状属性。123ggplot(data=mtcars, aes(x=wt, y=mpg, color=cyl, shape= cyl))+geom_point(size=3)+ scale_color_brewer(palette = &quot;Accent&quot;)+scale_shape_manual(values = c(2, 9, 16))#Accent是一调色板，可选点的形状见上 4 将连续变量映射给颜色、大小和形状等属性4.1 将连续性变量disp映射给颜色属性1ggplot(data=mtcars, aes(x=wt, y=mpg, color=disp))+geom_point(size=3) 从图中可以发现值越大对应的颜色越浅，以下是通过人为设置色阶使值大小与颜色深浅保持一致12ggplot(data=mtcars, aes(x=wt, y=mpg, color=disp))+geom_point(size=3)+ scale_color_gradient(low=&quot;lightblue&quot;, high=&quot;darkblue&quot;) 4.2 将连续性变量disp映射给大小属性1ggplot(data=mtcars, aes(x=wt, y=mpg, size=disp))+geom_point(color=&quot;red&quot;) 5 重叠点的处理当数据量非常大时，会导致数据重叠点非常严重，可通过使用半透明的点避免。alpha参数控制点的透明度。下面利用数据集diamonds来演示。12#check datahead(diamonds) 12#未使用透明点处理ggplot(data=diamonds, aes(x=carat, y=price))+geom_point() 12#使用alpha参数调整点透明度ggplot(data=diamonds, aes(x=carat, y=price))+geom_point(alpha=0.1) 6 为散点图添加拟合曲线12#使用数据集mtcarsggplot(data=mtcars, aes(x=wt, y=mpg))+geom_point()+stat_smooth(method=&quot;lm&quot;) 12#也可以去除掉拟合曲线的置信区间ggplot(data=mtcars, aes(x=wt, y=mpg))+geom_point()+stat_smooth(method=&quot;lm&quot;, se=FALSE) 123#也可以针对不同类型的cyl来进行拟合ggplot(data=mtcars, aes(x=wt, y=mpg, color=cyl))+geom_point()+stat_smooth(method=&quot;lm&quot;)]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>R&amp;ggcorrplot&amp;visualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ggplot2学习笔记之图形排列]]></title>
    <url>%2F2017%2F08%2F24%2Fggplot2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9B%BE%E5%BD%A2%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[R语言基本绘图函数中可以利用par()以及layout()来进行图形排列，但是这两个函数对于ggplot图则不太适用，本文主要讲解如何对多ggplot图形多页面进行排列。主要讲解如何利用包gridExtra、cowplot以及ggpubr中的函数进行图形排列。 绘制图形12345678#load packageslibrary(gridExtra)library(cowplot)library(ggpubr)#dataset ToothGrowth and mtcarsmtcars$name &lt;- rownames(mtcars)mtcars$cyl &lt;- as.factor(mtcars$cyl)head(mtcars[, c(&quot;name&quot;, &quot;wt&quot;,&quot;mpg&quot;, &quot;cyl&quot;)]) 12345678910111213#First let&apos;s create some plots#Box plot(bxp)bxp &lt;- ggboxplot(ToothGrowth, x=&quot;dose&quot;, y=&quot;len&quot;, color = &quot;dose&quot;, palette = &quot;jco&quot;)#Dot plot(dp)dp &lt;- ggdotplot(ToothGrowth, x=&quot;dose&quot;, y=&quot;len&quot;, color = &quot;dose&quot;, palette = &quot;jco&quot;, binwidth = 1)#An ordered Bar plot(bp)bp &lt;- ggbarplot(mtcars, x=&quot;name&quot;, y=&quot;mpg&quot;, fill=&quot;cyl&quot;, #change fill color by cyl color=&quot;white&quot;, #Set bar border colors to white palette = &quot;jco&quot;, #jco jourbal color palette sort.val = &quot;asc&quot;, #Sort the value in ascending order sort.by.groups = TRUE, #Sort inside each group x.text.angle=90 #Rotate vertically x axis texts )bp+font(&quot;x.text&quot;, size = 8) 1234567#Scatter plots(sp)sp &lt;- ggscatter(mtcars, x=&quot;wt&quot;, y=&quot;mpg&quot;, add = &quot;reg.line&quot;, #Add regression line conf.int = TRUE, #Add confidence interval color = &quot;cyl&quot;, palette = &quot;jco&quot;,#Color by group cyl shape = &quot;cyl&quot; #Change point shape by groups cyl )+ stat_cor(aes(color=cyl), label.x = 3) #Add correlation coefficientsp 图形排列 多幅图形排列于一面 ggpubr::ggarrange()1ggarrange(bxp, dp, bp+rremove(&quot;x.text&quot;), labels = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), ncol = 2, nrow = 2) cowplot::plot.grid()1plot_grid(bxp, dp, bp+rremove(&quot;x.text&quot;), labels = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), ncol = 2, nrow = 2) gridExtra::grid.arrange()1grid.arrange(bxp, dp, bp+rremove(&quot;x.text&quot;), ncol=2, nrow=2) 排列图形注释 ggpubr::annotate_figure() 12345figure &lt;- ggarrange(sp, bp+font(&quot;x.text&quot;, size = 10), ncol = 1, nrow = 2)annotate_figure(figure, top=text_grob(&quot;Visualizing mpg&quot;, color = &quot;red&quot;, face = &quot;bold&quot;, size=14), bottom = text_grob(&quot;Data source:\n mtcars data set&quot;, color = &quot;blue&quot;, hjust = 1, x=1, face = &quot;italic&quot;, size=10), left = text_grob(&quot;Figure arranged using ggpubr&quot;, color = &quot;green&quot;, rot = 90), right = &quot;I&apos;m done, thanks :-)!&quot;, fig.lab = &quot;Figure 1&quot;, fig.lab.face = &quot;bold&quot;) 绘图面板对齐 绘制生存曲线12345678910library(survival)head(colon[, c(1:4)])#Fit survival curvesfit &lt;- survfit(Surv(time, status)~adhere, data = colon)library(survminer)ggsurv &lt;- ggsurvplot(fit, data = colon, palette = &quot;jco&quot;, #jco palette pval = TRUE, pval.coord=c(500, 0.4), #Add p-value risk.table = TRUE #Add risk table)names(ggsurv)` 1## [1] &quot;plot&quot; &quot;table&quot; &quot;data.survplot&quot; &quot;data.survtable&quot; ggsurv是一个包含两部分的list plot：生存曲线 table：风险表可以用ggarrange()进行排列这两者1ggarrange(ggsurv$plot, ggsurv$table, heights = c(2, 0.7), ncol = 1, nrow = 2) 上图中的坐标轴没有对齐，可以通过参数align来设置1ggarrange(ggsurv$plot, ggsurv$table, heights = c(2, 0.7), ncol = 1, nrow = 2, align = &quot;v&quot;) 改变排列图的行列设置面板为两行两列，其中sp占据第一行的两列，bxp以及dp置于第二行的两列123ggarrange(sp, #First row with scatter plot(sp) ggarrange(bxp, dp, ncol = 2, labels = c(&quot;B&quot;,&quot;C&quot;)),#Second row with box and dot plot nrow = 2, labels = &quot;A&quot; #Labels of the scatter plot) R包cowplot cowplot::ggdraw()可以将图形置于特定位置, ggdraw()首先会初始化一个绘图面板， 接下来draw_plot()则是将图形绘制于初始化的绘图面板中，通过参数设置可以将图形置于特定位置。1draw_plot(plot, x=0, y=0, width=1, height=1) 其中： plot:将要放置的图形 x,y:控制图形位置 width,height:图形的宽度和高度 draw_plot_label():为图形添加标签1draw_plot_label(label, x=0, y=1, size=16, ...) 其中： label:标签 x,y:控制标签位置 size:标签字体大小 下面通过一个例子来讲解如何将多个图形放置在特定的位置。1234ggdraw()+ draw_plot(bxp, x=0, y=0.5, width=0.5, height = 0.5)+draw_plot(dp, x=0.5, y=0.5, width = 0.5, height = 0.5)+ draw_plot(bp, x=0, y=0, width = 1.5, height = 0.5)+ draw_plot_label(label = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), size = 15, x=c(0, 0.5, 0), y=c(1, 1, 0.5)) R包gridExtra gridExtra::arrangeGrop()改变行列分布 下面将sp置于第一行并横跨两列，而bxp和dp分别分布于第二行两列123grid.arrange(sp, #First row with one plot spaning over 2 columnsarrangeGrob(bxp, dp, ncol = 2), #Second row with 2plots in 2 different columns nrow=2) #number of rows 也可以通过函数grid.arrange中的layout_matrix来设置复杂的图形布局123grid.arrange(bp, #bar plot spaning two columns bxp, sp, #box plot amd scatter plot ncol=2, nrow=2, layout_matrix=rbind(c(1, 1), c(2, 3))) 要相对grid.arrange()以及arrangeGrob()的输出进行注释，首先要利用as_ggplot()将其转化为ggplot图形，进而利用函数draw_plot_label()对其进行注释。1234gt &lt;- arrangeGrob(bp, bxp, sp, layout_matrix = rbind(c(1,1),c(2, 3)))p &lt;- as_ggplot(gt)+ draw_plot_label(label = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), size = 15, x=c(0, 0, 0.5), y=c(1, 0.5, 0.5))p R包grid R包grid中的grid.layout()可以设置复杂的图形布局，viewport()可以定义一个区域用来安置图形排列，print()则用来将图形置于特定区域。 总结起来步骤如下： 创建图形p1,p2,p3,… grid.newpage()创建一个画布 创建图形布局，几行几列 定义布局的矩形区域 print：将图形置于特定区域12345678910111213library(grid)#Move to a new pagegrid.newpage()#Create layout:nrow=3, ncol=2pushViewport(viewport(layout = grid.layout(nrow=3, ncol=2)))#A helper function to define a region on the layoutdefine_region &lt;- function(row, col)&#123; viewport(layout.pos.row = row, layout.pos.col = col)&#125;#Arrange the plotsprint(sp, vp=define_region(row=1, col=1:2)) #Span over two columnsprint(bxp, vp=define_region(row=2, col=1))print(dp, vp=define_region(row=2, col=2))print(bp+rremove(&quot;x.text&quot;), vp=define_region(row=3, col=1:2)) 设置共同图例 ggpubr::ggarrange()可以为组合图形添加共同图例 common.legeng=TRUE:在图形旁边添加图例 legend：指定legend的位置，主要选项有：top、bottom、left、right。1ggarrange(bxp, dp, labels = c(&quot;A&quot;, &quot;B&quot;), common.legend = TRUE, legend = &quot;bottom&quot;) 含有边际密度图的散点图1234567891011sp &lt;- ggscatter(iris, x=&quot;Sepal.Length&quot;, y=&quot;Sepal.Width&quot;, color=&quot;Species&quot;, palette = &quot;jco&quot;, size=3, alpha=0.6)+border()#Marginal density plot of x(top panel) and y(right panel)xplot &lt;- ggdensity(iris, &quot;Sepal.Length&quot;, fill=&quot;Species&quot;,palette = &quot;jco&quot;)yplot &lt;- ggdensity(iris, &quot;Sepal.Width&quot;, fill=&quot;Species&quot;, palette = &quot;jco&quot;)+rotate()#Clean the plotsxplot &lt;- xplot+clean_theme()yplot &lt;- yplot+clean_theme()#Arrange the plotsggarrange(xplot, NULL, sp, yplot, ncol = 2, nrow = 2, align = &quot;hv&quot;, widths = c(2, 1), heights = c(1, 2), common.legend = TRUE) ggplot图、文本、表格组合12345678910density.p &lt;- ggdensity(iris, x=&quot;Sepal.Length&quot;, fill=&quot;Species&quot;, palette = &quot;jco&quot;)#Compute the summary table of Sepal.Lengthstable &lt;- desc_statby(iris, measure.var = &quot;Sepal.Length&quot;, grps = &quot;Species&quot;)stable &lt;- stable[, c(&quot;Species&quot;, &quot;length&quot;, &quot;mean&quot;, &quot;sd&quot;)]#Summary table plot, medium and themestable.p &lt;- ggtexttable(stable, rows = NULL, theme = ttheme(&quot;mOrange&quot;))text &lt;- paste(&quot;iris data set gives the measurements in cm&quot;, &quot;of the variables sepal length and width&quot;, &quot;and petal length and width, respectively,&quot;, &quot;for 50 flowers from each of 3 species of iris.&quot;, &quot;The species are Iris setosa, versicolor, and virginica.&quot;, sep = &quot; &quot;)text.p &lt;- ggparagraph(text = text, face = &quot;italic&quot;, size = 11, color = &quot;black&quot;)#Arrange the plots on the same pageggarrange(density.p, stable.p, text.p, ncol = 1, nrow = 3, heights = c(1, 0.5, 0.3)) ggplot图形中嵌入图形元素 ggplot2::annotation_custom()可以添加各种图形元素到ggplot图中1annotation_custom(grob, xmin, xmax, ymin, ymax) 其中： grob:要添加的图形元素 xmin, xmax: x轴方向位置（水平方向） ymin, ymax: y轴方向位置（竖直方向） ggplot图形中添加table1density.p+annotation_custom(ggplotGrob(stable.p), xmin = 5.5, xmax = 8, ymin = 0.7) ggplot图形中添加box plot1234567891011121314151617181920sp &lt;- ggscatter(iris, x=&quot;Sepal.Length&quot;, y=&quot;Sepal.Width&quot;, color = &quot;Species&quot;, palette = &quot;jco&quot;, size = 3, alpha=0.6)xbp &lt;- ggboxplot(iris$Sepal.Length, width = 0.3, fill = &quot;lightgray&quot;)+ rotate()+theme_transparent()ybp &lt;- ggboxplot(iris$Sepal.Width, width = 0.3, fill=&quot;lightgray&quot;)+theme_transparent()# Create the external graphical objects# called a &quot;grop&quot; in Grid terminologyxbp_grob &lt;- ggplotGrob(xbp)ybp_grob &lt;- ggplotGrob(ybp)#place box plots inside the scatter plotxmin &lt;- min(iris$Sepal.Length)xmax &lt;- max(iris$Sepal.Length)ymin &lt;- min(iris$Sepal.Width)ymax &lt;- max(iris$Sepal.Width)yoffset &lt;- (1/15)*ymaxxoffset &lt;- (1/15)*xmax# Insert xbp_grob inside the scatter plotsp+annotation_custom(grob = xbp_grob, xmin = xmin, xmax = xmax, ymin = ymin-yoffset, ymax = ymin+yoffset)+# Insert ybp_grob inside the scatter plotannotation_custom(grob = ybp_grob, xmin = xmin-xoffset, xmax=xmin+xoffset, ymin=ymin, ymax=ymax) ggplot图形添加背景12#import the imageimg.file &lt;- system.file(file.path(&quot;images&quot;, &quot;background-image.png&quot;), package = &quot;ggpubr&quot;)img &lt;- png::readPNG(img.file) 利用ggpubr::background_image()为ggplot图形添加背景图12345library(ggplot2)library(ggpubr)ggplot(iris, aes(Species,Sepal.Length))+background_image(img)+geom_boxplot(aes(fill=Species), color=&quot;white&quot;)+ fill_palette(&quot;jco&quot;) 修改透明度123ggplot(iris, aes(Species,Sepal.Length))+background_image(img)+geom_boxplot(aes(fill=Species), color=&quot;white&quot;, alpha=0.5)+ fill_palette(&quot;jco&quot;) 多页排列 日常工作中我们有时要绘制许多图，假如我们有16幅图，每页排列4张的话就需要4页才能排完，而ggpubr::ggarrange()可以通过制定行列数自动在多页之间进行图形排列1multi.page &lt;-ggarrange(bxp, dp, bp, sp, nrow = 1, ncol = 2) 上述代码返回两页每页两图1multi.page[[1]] 1multi.page[[2]] 利用ggarrange()嵌套布局1234p1 &lt;- ggarrange(sp, bp+font(&quot;x.text&quot;, size = 9), ncol = 1, nrow = 2)p2 &lt;- ggarrange(density.p, stable.p, text.p, ncol = 1, nrow = 3, heights = c(1, 0.5, 0.3))ggarrange(p1, p2, ncol = 2, nrow = 1) SessionInfo12345678910111213141516171819202122232425262728293031323334353637383940sessionInfo()## R version 3.4.1 (2017-06-30)## Platform: x86_64-w64-mingw32/x64 (64-bit)## Running under: Windows 10 x64 (build 15063)## ## Matrix products: default## ## locale:## [1] LC_COLLATE=Chinese (Simplified)_China.936 ## [2] LC_CTYPE=Chinese (Simplified)_China.936 ## [3] LC_MONETARY=Chinese (Simplified)_China.936## [4] LC_NUMERIC=C## [5] LC_TIME=Chinese (Simplified)_China.936 ## ## attached base packages:## [1] grid stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages:## [1] survminer_0.4.0 survival_2.41-3 ggpubr_0.1.5 magrittr_1.5 ## [5] cowplot_0.8.0 ggplot2_2.2.1 gridExtra_2.2.1## ## loaded via a namespace (and not attached):## [1] zoo_1.8-0 purrr_0.2.3 reshape2_1.4.2 ## [4] splines_3.4.1 lattice_0.20-35 colorspace_1.3-2 ## [7] htmltools_0.3.6 yaml_2.1.14 survMisc_0.5.4## [10] rlang_0.1.2 foreign_0.8-69 glue_1.1.1 ## [13] bindrcpp_0.2 bindr_0.1 plyr_1.8.4 ## [16] stringr_1.2.0 munsell_0.4.3 gtable_0.2.0 ## [19] ggsci_2.7 psych_1.7.5 evaluate_0.10.1 ## [22] labeling_0.3 knitr_1.17 parallel_3.4.1 ## [25] broom_0.4.2 Rcpp_0.12.12 xtable_1.8-2 ## [28] scales_0.4.1 backports_1.1.0 cmprsk_2.2-7 ## [31] km.ci_0.5-2 mnormt_1.5-5 png_0.1-7 ## [34] digest_0.6.12 stringi_1.1.5 dplyr_0.7.2 ## [37] KMsurv_0.1-5 rprojroot_1.2 tools_3.4.1 ## [40] lazyeval_0.2.0 tibble_1.3.3 tidyr_0.7.0 ## [43] pkgconfig_2.0.1 Matrix_1.2-11 data.table_1.10.4## [46] assertthat_0.2.0 rmarkdown_1.6 R6_2.2.2 ## [49] nlme_3.1-131 compiler_3.4.1 联系方式： wechat: yt056410 Email: tyan@zju.edu.cn QQ: 1051927088 GitHub: https://github.com/YTLogos 简书: http://www.jianshu.com/u/bd001545cf0b 博客: https://ytlogos.github.io/ 个人简介：严涛 浙江大学作物遗传育种在读研究生（生物信息学方向） 伪码农，R语言爱好者，爱开源]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>R&amp;ggpubr&amp;visualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[r4ds学习笔记之ggplot2]]></title>
    <url>%2F2017%2F07%2F01%2Fr4ds%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bggplot2%2F</url>
    <content type="text"><![CDATA[为了进一步加强以及整合自己data science的能力，最近打算在我的博客开辟一个新类r4ds，专门用来记录学习Hadley Wickham大神的新作R for Data Science的读书笔记。该书推荐我们入门data science可以从可视化开始，这也是该书目录布局的第一章。因此开始学习R语言可视化。 前提本章主要聚焦于可视化包ggplot2,为了写这本书，大神专门整合了一系列神包成为一个包tidyverse，因此第一步就是要先安装该包并加载。1234#install tidyverseinstall.packages(&quot;tidyverse&quot;)#load tidyverselibrary(tidyverse) ggplot2简介利用数据集mpg来探究发动机大小跟好友耗油是否存在某种关系，先check一下该数据集。1head(mpg) 在各个变量中： disp:车发动机大小 hwy:衡量耗油率的一个指标，更多信息可？mpg查看 要探究displ与hwy的关系，最快就是画个图了1ggplot(data=mpg)+ geom_point(mapping = aes(x=displ, y=hwy)) 图中显示两者呈现负相关，disp越大，hwy越低。ggplot2绘图规则主要如下：12ggplot(data=&lt;DATA&gt;)+ &lt;GEOM_FUNCTION&gt;(mapping=aes(&gt;MAPPINGS&gt;)) ggplot()会创建一个底板，然后可以通过geom_function()不断地添加图形元素，进行丰富。12p &lt;- ggplot(mpg)#create an empty graphp+geom_point(aes(x=displ, y=hwy))#add a layer to the empty graph 美学映射Aesthetic Mappings美学映射在ggplot2中是一个十分重要的概念，比如前文我们将displ、hwy分别映射给x、y轴，同时还可以用来控制图形元素大小、形状、颜色等属性。12ggplot(mpg)+ geom_point(aes(x=displ, y=hwy, color=class))#将class映射给颜色属性，这样不同class就表现不同颜色 可以看到，通过颜色映射ggplot2会自动创建一个legend，需要注意的是这里颜色颜色我们是利用class，这是一个离散性变量，如果我们将之映射给点的size，则会出现warning,至于原因，看warning。1ggplot(mpg)+ geom_point(aes(x=displ, y=hwy, size=class)) 或者将class映射给alpha参数，这是一个控制点透明度的参数;shape是一个控制形状的参数1ggplot(mpg)+ geom_point(aes(x=displ, y=hwy, alpha=class)) 1ggplot(mpg)+ geom_point(aes(x=displ, y=hwy, shape=class)) 发现当映射shape其中SUV是没有形状的，这是因为ggplot2只默认6种形状，这个问题后续解决。 需要注意的是映射参数必须在aes(),不然就无法映射。1ggplot(mpg)+ geom_point(aes(x=displ, y=hwy), color=&quot;blue&quot;)#all the points are blue 今天就讲到这，下次继续 SessionInfo123456789101112131415161718192021222324252627282930313233343536373839sessionInfo()## R version 3.4.1 (2017-06-30)## Platform: x86_64-w64-mingw32/x64 (64-bit)## Running under: Windows 8.1 x64 (build 9600)## ## Matrix products: default## ## locale:## [1] LC_COLLATE=Chinese (Simplified)_China.936 ## [2] LC_CTYPE=Chinese (Simplified)_China.936 ## [3] LC_MONETARY=Chinese (Simplified)_China.936## [4] LC_NUMERIC=C ## [5] LC_TIME=Chinese (Simplified)_China.936 ## ## attached base packages:## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages:## [1] forcats_0.2.0 stringr_1.2.0 dplyr_0.7.1 ## [4] purrr_0.2.2.2 readr_1.1.1 tidyr_0.6.3 ## [7] tibble_1.3.3 ggplot2_2.2.1 tidyverse_1.1.1.9000## ## loaded via a namespace (and not attached):## [1] Rcpp_0.12.11 cellranger_1.1.0 compiler_3.4.1 ## [4] plyr_1.8.4 bindr_0.1 tools_3.4.1 ## [7] digest_0.6.12 lubridate_1.6.0 jsonlite_1.5 ## [10] evaluate_0.10.1 nlme_3.1-131 gtable_0.2.0 ## [13] lattice_0.20-35 pkgconfig_2.0.1 rlang_0.1.1 ## [16] psych_1.7.5 rstudioapi_0.6 yaml_2.1.14 ## [19] parallel_3.4.1 haven_1.0.0 bindrcpp_0.2 ## [22] xml2_1.1.1 httr_1.2.1 knitr_1.16 ## [25] hms_0.3 rprojroot_1.2 grid_3.4.1 ## [28] glue_1.1.1 R6_2.2.2 readxl_1.0.0 ## [31] foreign_0.8-69 rmarkdown_1.6 modelr_0.1.0 ## [34] reshape2_1.4.2 magrittr_1.5 clisymbols_1.2.0 ## [37] boxes_0.0.0.9000 backports_1.1.0 scales_0.4.1 ## [40] htmltools_0.3.6 rvest_0.3.2 assertthat_0.2.0 ## [43] mnormt_1.5-5 colorspace_1.3-2 labeling_0.3 ## [46] stringi_1.1.5 lazyeval_0.2.0 munsell_0.4.3 ## [49] broom_0.4.2 crayon_1.3.2.9000 联系方式：wechat: yt056410Email: tyan@zju.edu.cnQQ: 1051927088GitHub: https://github.com/YTLogos简书: http://www.jianshu.com/u/bd001545cf0b博客: https://ytlogos.github.io/ 个人简介：严涛浙江大学作物遗传育种在读研究生（生物信息学方向）伪码农，R语言爱好者，爱开源]]></content>
      <categories>
        <category>r4ds</category>
      </categories>
      <tags>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R语言data manipulation学习笔记之subset data]]></title>
    <url>%2F2017%2F06%2F29%2FR%E8%AF%AD%E8%A8%80data-manipulation%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bsubset-data%2F</url>
    <content type="text"><![CDATA[数据分析过程中我们常常需要从数据集中抽取部分数据，本文将介绍如何提取子数据集，主要利用R自带的函数，以后会专门介绍data manipulation包dplyr。 提取子数据集主要分为select以及exclude，这里主要介绍两种方法，一是利用操作符[]进行选取，二是利用subset()进行抽取。 利用[]进行提取123456789101112#use the iris datasethead(iris)## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa## 2 4.9 3.0 1.4 0.2 setosa## 3 4.7 3.2 1.3 0.2 setosa## 4 4.6 3.1 1.5 0.2 setosa## 5 5.0 3.6 1.4 0.2 setosa## 6 5.4 3.9 1.7 0.4 setosa# check the column namenames(iris)## [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; &quot;Species&quot; 加入我们想要提取Sepal.Length、Sepal.Width两列数据，可以使用如下代码：123456789dt1 &lt;- iris[, c(&quot;Sepal.Length&quot;,&quot;Sepal.Width&quot;)]head(dt1)## Sepal.Length Sepal.Width## 1 5.1 3.5## 2 4.9 3.0## 3 4.7 3.2## 4 4.6 3.1## 5 5.0 3.6## 6 5.4 3.9 123456789#也可以直接用列序号代替，比如这里我们想要提要前两列dt2 &lt;- iris[, c(1, 2)]head(dt2)## Sepal.Length Sepal.Width## 1 5.1 3.5## 2 4.9 3.0## 3 4.7 3.2## 4 4.6 3.1## 5 5.0 3.6## 6 5.4 3.9 如果我们需要删除前两列，只需在序号之前添加符号 - 就行123456789dt3 &lt;- iris[, c(-1, -2)]head(dt3)## Petal.Length Petal.Width Species ## 1 1.4 0.2 setosa## 2 1.4 0.2 setosa## 3 1.3 0.2 setosa## 4 1.5 0.2 setosa## 5 1.4 0.2 setosa## 6 1.7 0.4 setosa 可以看出十分简单就可以提取子数据集，下面介绍subset()，subset()相比于[]主要是可以方便的根据条件提取子数据集。 利用subset()进行提取1234567891011121314#create a datasetfy &lt;- c(2010,2011,2012,2010,2011,2012,2010,2011,2012)company &lt;- c(&quot;Apple&quot;,&quot;Apple&quot;,&quot;Apple&quot;,&quot;Google&quot;,&quot;Google&quot;,&quot;Google&quot;,&quot;Microsoft&quot;,&quot;Microsoft&quot;,&quot;Microsoft&quot;)revenue &lt;- c(65225,108249,156508,29321,37905,50175,62484,69943,73723)profit &lt;- c(14013,25922,41733,8505,9737,10737,18760,23150,16978) companiesData &lt;- data.frame(fy, company, revenue, profit)head(companiesData)## fy company revenue profit## 1 2010 Apple 65225 14013## 2 2011 Apple 108249 25922## 3 2012 Apple 156508 41733## 4 2010 Google 29321 8505## 5 2011 Google 37905 9737## 6 2012 Google 50175 10737 假如我们想要提取revenue超过十万的公司123456com1 &lt;- subset(companiesData, revenue&gt;100000)head(com1)## fy company revenue profit## 2 2011 Apple 108249 25922## 3 2012 Apple 156508 41733 或者我们想要提取在2012年revenue超过6万的公司123456com2 &lt;- subset(companiesData, fy==&quot;2012&quot;&amp;revenue&gt;60000)head(com2)## fy company revenue profit## 3 2012 Apple 156508 41733## 9 2012 Microsoft 73723 16978 或者提取在2012年revenue超过6万、profit超过4万的公司12345com3 &lt;- subset(companiesData, fy==&quot;2012&quot;&amp;revenue&gt;60000&amp;profit&gt;40000)com3## fy company revenue profit## 3 2012 Apple 156508 41733 条件选择也可以使用或，比如我们想要提取profit超过2万或者revenue低于5万的公司12345678com4 &lt;- subset(companiesData, revenue&lt;50000|profit&gt;20000)com4## fy company revenue profit ## 2 2011 Apple 108249 25922## 3 2012 Apple 156508 41733## 4 2010 Google 29321 8505## 5 2011 Google 37905 9737## 8 2011 Microsoft 69943 23150 本文只是粗略的讲解，其实subset()的用法很广，有兴趣的朋友可以自行探索。 sessionInfo1234567891011121314151617181920212223242526sessionInfo()## R version 3.4.0 (2017-04-21)## Platform: x86_64-pc-linux-gnu (64-bit)## Running under: Ubuntu 16.04.2 LTS## ## Matrix products: default## BLAS: /usr/lib/atlas-base/atlas/libblas.so.3.0## LAPACK: /usr/lib/atlas-base/atlas/liblapack.so.3.0## ## locale:## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages:## [1] stats graphics grDevices utils datasets methods base ## ## loaded via a namespace (and not attached):## [1] compiler_3.4.0 backports_1.1.0 magrittr_1.5 rprojroot_1.2 ## [5] tools_3.4.0 htmltools_0.3.6 yaml_2.1.14 Rcpp_0.12.11 ## [9] stringi_1.1.5 rmarkdown_1.6 knitr_1.16 stringr_1.2.0 ## [13] digest_0.6.12 evaluate_0.10.1 联系方式：wechat: yt056410Email: tyan@zju.edu.cnQQ: 1051927088GitHub: https://github.com/YTLogos简书: http://www.jianshu.com/u/bd001545cf0b博客: https://ytlogos.github.io/ 个人简介：严涛浙江大学作物遗传育种在读研究生（生物信息学方向）伪码农，R语言爱好者，爱开源]]></content>
      <categories>
        <category>Data Manipulation</category>
      </categories>
      <tags>
        <tag>data management</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R语言data manipulation学习笔记之创建变量、重命名、数据融合]]></title>
    <url>%2F2017%2F06%2F28%2FR%E8%AF%AD%E8%A8%80data-manipulation%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%8F%98%E9%87%8F%E3%80%81%E9%87%8D%E5%91%BD%E5%90%8D%E3%80%81%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88%2F</url>
    <content type="text"><![CDATA[数据分析中数据处理也就是data manipulation是十分繁琐的，为此我将在博客里特意建一个分类：Data Manipulation。本文将讲讲如何在R语言中创建变量、重命名以及merge。 #create a dataset12345678910111213fy &lt;- c(2010,2011,2012,2010,2011,2012,2010,2011,2012)company &lt;- c(&quot;Apple&quot;,&quot;Apple&quot;,&quot;Apple&quot;,&quot;Google&quot;,&quot;Google&quot;,&quot;Google&quot;,&quot;Microsoft&quot;,&quot;Microsoft&quot;,&quot;Microsoft&quot;)revenue &lt;- c(65225,108249,156508,29321,37905,50175,62484,69943,73723)profit &lt;- c(14013,25922,41733,8505,9737,10737,18760,23150,16978) companiesData &lt;- data.frame(fy, company, revenue, profit)head(companiesData)## fy company revenue profit## 1 2010 Apple 65225 14013## 2 2011 Apple 108249 25922## 3 2012 Apple 156508 41733## 4 2010 Google 29321 8505## 5 2011 Google 37905 9737## 6 2012 Google 50175 10737 接下来我们需要查看数据集的结构，用str()函数查看123456str(companiesData)## &apos;data.frame&apos;: 9 obs. of 4 variables:## $ fy : num 2010 2011 2012 2010 2011 ...## $ company: Factor w/ 3 levels &quot;Apple&quot;,&quot;Google&quot;,..: 1 1 1 2 2 2 3 3 3## $ revenue: num 65225 108249 156508 29321 37905 ...## $ profit : num 14013 25922 41733 8505 9737 ... 可以看到年份fy这里是是数值型，我们需要更改为因子型，方便后期处理1companiesData$fy &lt;- factor(companiesData$fy, ordered = TRUE) 现在数据已经整理过好了，下面我们来添加变量，比如我们可以看看各个公司的利润率12345678910companiesData$margin &lt;- (companiesData$profit/companiesData$revenue)*100#查看数据head(companiesData)## fy company revenue profit margin## 1 2010 Apple 65225 14013 21.48409## 2 2011 Apple 108249 25922 23.94664## 3 2012 Apple 156508 41733 26.66509## 4 2010 Google 29321 8505 29.00651## 5 2011 Google 37905 9737 25.68790## 6 2012 Google 50175 10737 21.39910 小数点位数太多了，这里我们保留一位123456789companiesData$margin &lt;- round(companiesData$margin, 1)head(companiesData)## fy company revenue profit margin## 1 2010 Apple 65225 14013 21.5## 2 2011 Apple 108249 25922 23.9## 3 2012 Apple 156508 41733 26.7## 4 2010 Google 29321 8505 29.0## 5 2011 Google 37905 9737 25.7## 6 2012 Google 50175 10737 21.4 这样我们就创建了一个新的变量margin，当然也可以删除变量，只要复制需要删除的变量NULL就行了。12345678910#delete variable margincompaniesData$margin &lt;- NULLhead(companiesData)## fy company revenue profit## 1 2010 Apple 65225 14013## 2 2011 Apple 108249 25922## 3 2012 Apple 156508 41733## 4 2010 Google 29321 8505## 5 2011 Google 37905 9737## 6 2012 Google 50175 10737 再顺便介绍一下transform函数，用于创建变量，transform的格式如下12345678910dataFrame &lt;- transform(dataFrame, newColumn = oldColumn1 + oldColumn2)companiesData &lt;- transform(companiesData, margin=round((profit/revenue)*100), 1)head(companiesData)## fy company revenue profit margin X1## 1 2010 Apple 65225 14013 21 1## 2 2011 Apple 108249 25922 24 1## 3 2012 Apple 156508 41733 27 1## 4 2010 Google 29321 8505 29 1## 5 2011 Google 37905 9737 26 1## 6 2012 Google 50175 10737 21 1 接下来讲一下merge，主要是merge函数，它要求进行融合的两个数据集需要有共同的变量即id，使用格式如下：1finaldt &lt;- merge(dataset1, dataset2, by=&quot;id&quot;) 这里我们再创建一个数据集用于merge123456789#creat another datasetcompany &lt;- c(&quot;Apple&quot;,&quot;Google&quot;,&quot;Microsoft&quot;)ava1 &lt;- c(1,2,3)data2 &lt;- data.frame(company, ava1)head(data2)## company ava1## 1 Apple 1## 2 Google 2## 3 Microsoft 3 数据集data2与数据集companiesData具有共同的变量company(id)12#merge the two datasetnewdata &lt;- merge(companiesData, data2, by=&quot;company&quot;) 这样就得到一个完整的数据集了，当然添加行、列还有两个很有用的函数：rbind()以及cbind(),这里就不介绍了 最后讲一下重命名，其实很简单1234567891011companiesData$company &lt;- c(&quot;A&quot;, &quot;A&quot;, &quot;A&quot;, &quot;G&quot;, &quot;G&quot;, &quot;G&quot;, &quot;M&quot;, &quot;M&quot;, &quot;M&quot;)head(companiesData)## fy company revenue profit margin X1## 1 2010 A 65225 14013 21 1## 2 2011 A 108249 25922 24 1## 3 2012 A 156508 41733 27 1## 4 2010 G 29321 8505 29 1## 5 2011 G 37905 9737 26 1## 6 2012 G 50175 10737 21 1#rename the colnamecolnames(companiesData) &lt;- c(&quot;Year&quot;, &quot;Com&quot;, &quot;Rev&quot;, &quot;Pro&quot;, &quot;Mar&quot;) #seessioninfo12345678910111213141516171819202122sessionInfo()## R version 3.4.0 (2017-04-21)## Platform: x86_64-w64-mingw32/x64 (64-bit)## Running under: Windows 8.1 x64 (build 9600)## ## Matrix products: default## ## locale:## [1] LC_COLLATE=Chinese (Simplified)_China.936 ## [2] LC_CTYPE=Chinese (Simplified)_China.936 ## [3] LC_MONETARY=Chinese (Simplified)_China.936## [4] LC_NUMERIC=C ## [5] LC_TIME=Chinese (Simplified)_China.936 ## ## attached base packages:## [1] stats graphics grDevices utils datasets methods base ## ## loaded via a namespace (and not attached):## [1] compiler_3.4.0 backports_1.1.0 magrittr_1.5 rprojroot_1.2 ## [5] tools_3.4.0 htmltools_0.3.6 yaml_2.1.14 Rcpp_0.12.11 ## [9] stringi_1.1.5 rmarkdown_1.5 knitr_1.16 stringr_1.2.0 ## [13] digest_0.6.12 evaluate_0.10 联系方式：wechat: yt056410Email: tyan@zju.edu.cnQQ: 1051927088GitHub: https://github.com/YTLogos简书: http://www.jianshu.com/u/bd001545cf0b博客: https://ytlogos.github.io/ 个人简介：严涛浙江大学作物遗传育种在读研究生（生物信息学方向）伪码农，R语言爱好者，爱开源]]></content>
      <categories>
        <category>Data Manipulation</category>
      </categories>
      <tags>
        <tag>manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R语言可视化学习笔记之ggpubr包]]></title>
    <url>%2F2017%2F06%2F26%2FR%E8%AF%AD%E8%A8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bggpubr%E5%8C%85%2F</url>
    <content type="text"><![CDATA[Hadley Wickham创建的可视化包ggplot2可以流畅地进行优美的可视化，但是如果要通过ggplot2定制一套图形，尤其是适用于杂志期刊等出版物的图形，对于那些没有深入了解ggplot2的人来说就有点困难了，ggplot2的部分语法是很晦涩的。为此Alboukadel Kassambara创建了基于ggplot2的可视化包ggpubr用于绘制符合出版物要求的图形。 安装及加载ggpubr包安装方式有两种： 直接从CRAN安装： 1install.packages(&quot;ggpubr&quot;) 从GitHub上安装最新版本： 12if(!require(devtools)) install.packages(&quot;devtools&quot;) devtools::install_github(&quot;kassambara/ggpubr&quot;) 安装完之后直接加载就行：1library(ggpubr) #ggpubr可绘制图形：ggpubr可绘制大部分我们常用的图形，下面一一介绍。 ##分布图(Distribution)12345#构建数据集set.seed(1234)df &lt;- data.frame( sex=factor(rep(c(&quot;f&quot;, &quot;M&quot;), each=200)), weight=c(rnorm(200, 55), rnorm(200, 58)))head(df) 1234567## sex weight## 1 f 53.79293## 2 f 55.27743## 3 f 56.08444## 4 f 52.65430## 5 f 55.42912## 6 f 55.50606 ###密度分布图以及边际地毯线并添加平均值线12ggdensity(df, x=&quot;weight&quot;, add = &quot;mean&quot;, rug = TRUE, color = &quot;sex&quot;, fill = &quot;sex&quot;,palette = c(&quot;#00AFBB&quot;, &quot;#E7B800&quot;)) ###带有均值线和边际地毯线的直方图12gghistogram(df, x=&quot;weight&quot;, add = &quot;mean&quot;, rug = TRUE, color = &quot;sex&quot;, fill = &quot;sex&quot;,palette = c(&quot;#00AFBB&quot;, &quot;#E7B800&quot;)) ###箱线图与小提琴图1234#加载数据集ToothGrowthdata(&quot;ToothGrowth&quot;)df1 &lt;- ToothGrowthhead(df1) 1234567## len supp dose## 1 4.2 VC 0.5## 2 11.5 VC 0.5## 3 7.3 VC 0.5## 4 5.8 VC 0.5## 5 6.4 VC 0.5## 6 10.0 VC 0.5 123p &lt;- ggboxplot(df1, x=&quot;dose&quot;, y=&quot;len&quot;, color = &quot;dose&quot;, palette = c(&quot;#00AFBB&quot;, &quot;#E7B800&quot;, &quot;#FC4E07&quot;), add = &quot;jitter&quot;, shape=&quot;dose&quot;)#增加了jitter点，点shape由dose映射p 增加不同组间的p-value值，可以自定义需要标注的组间比较123my_comparisons &lt;- list(c(&quot;0.5&quot;, &quot;1&quot;), c(&quot;1&quot;, &quot;2&quot;), c(&quot;0.5&quot;, &quot;2&quot;))p+stat_compare_means(comparisons = my_comparisons)+#不同组间的比较stat_compare_means(label.y = 50) ###内有箱线图的小提琴图12345ggviolin(df1, x=&quot;dose&quot;, y=&quot;len&quot;, fill = &quot;dose&quot;, palette = c(&quot;#00AFBB&quot;, &quot;#E7B800&quot;, &quot;#FC4E07&quot;), add = &quot;boxplot&quot;, add.params = list(fill=&quot;white&quot;))+ stat_compare_means(comparisons = my_comparisons, label = &quot;p.signif&quot;)+#label这里表示选择显著性标记（星号） stat_compare_means(label.y = 50) ###条形图12345data(&quot;mtcars&quot;)df2 &lt;- mtcarsdf2$cyl &lt;- factor(df2$cyl)df2$name &lt;- rownames(df2)#添加一行namehead(df2[, c(&quot;name&quot;, &quot;wt&quot;, &quot;mpg&quot;, &quot;cyl&quot;)]) 按从小到大顺序绘制条形图（不分组排序）12345ggbarplot(df2, x=&quot;name&quot;, y=&quot;mpg&quot;, fill = &quot;cyl&quot;, color = &quot;white&quot;, palette = &quot;jco&quot;,#杂志jco的配色 sort.val = &quot;desc&quot;,#下降排序 sort.by.groups=FALSE,#不按组排序 x.text.angle=60) 按组进行排序12345ggbarplot(df2, x=&quot;name&quot;, y=&quot;mpg&quot;, fill = &quot;cyl&quot;, color = &quot;white&quot;, palette = &quot;jco&quot;,#杂志jco的配色 sort.val = &quot;asc&quot;,#上升排序,区别于desc，具体看图演示 sort.by.groups=TRUE,#按组排序 x.text.angle=90) ###偏差图偏差图展示了与参考值之间的偏差123df2$mpg_z &lt;- (df2$mpg-mean(df2$mpg))/sd(df2$mpg)df2$mpg_grp &lt;- factor(ifelse(df2$mpg_z&lt;0, &quot;low&quot;, &quot;high&quot;), levels = c(&quot;low&quot;, &quot;high&quot;))head(df2[, c(&quot;name&quot;, &quot;wt&quot;, &quot;mpg&quot;, &quot;mpg_grp&quot;, &quot;cyl&quot;)]) 绘制排序过的条形图123ggbarplot(df2, x=&quot;name&quot;, y=&quot;mpg_z&quot;, fill = &quot;mpg_grp&quot;, color = &quot;white&quot;, palette = &quot;jco&quot;, sort.val = &quot;asc&quot;, sort.by.groups = FALSE, x.text.angle=60, ylab = &quot;MPG z-score&quot;, xlab = FALSE, legend.title=&quot;MPG Group&quot;) 坐标轴变换1234ggbarplot(df2, x=&quot;name&quot;, y=&quot;mpg_z&quot;, fill = &quot;mpg_grp&quot;, color = &quot;white&quot;, palette = &quot;jco&quot;, sort.val = &quot;desc&quot;, sort.by.groups = FALSE, x.text.angle=90, ylab = &quot;MPG z-score&quot;, xlab = FALSE, legend.title=&quot;MPG Group&quot;, rotate=TRUE, ggtheme = theme_minimal()) ##点图(Dot charts) ###棒棒糖图(Lollipop chart)棒棒图可以代替条形图展示数据123ggdotchart(df2, x=&quot;name&quot;, y=&quot;mpg&quot;, color = &quot;cyl&quot;, palette = c(&quot;#00AFBB&quot;, &quot;#E7B800&quot;, &quot;#FC4E07&quot;), sorting = &quot;ascending&quot;, add = &quot;segments&quot;, ggtheme = theme_pubr()) 可以自设置各种参数12345ggdotchart(df2, x=&quot;name&quot;, y=&quot;mpg&quot;, color = &quot;cyl&quot;, palette = c(&quot;#00AFBB&quot;, &quot;#E7B800&quot;, &quot;#FC4E07&quot;), sorting = &quot;descending&quot;, add = &quot;segments&quot;, rotate = TRUE, group = &quot;cyl&quot;, dot.size = 6, label = round(df2$mpg), font.label = list(color=&quot;white&quot;, size=9, vjust=0.5), ggtheme = theme_pubr()) ###偏差图123456ggdotchart(df2, x=&quot;name&quot;, y=&quot;mpg_z&quot;, color = &quot;cyl&quot;, palette = c(&quot;#00AFBB&quot;, &quot;#E7B800&quot;, &quot;#FC4E07&quot;), sorting = &quot;descending&quot;, add = &quot;segment&quot;, add.params = list(color=&quot;lightgray&quot;, size=2), group = &quot;cyl&quot;, dot.size = 6, label = round(df2$mpg_z, 1), font.label = list(color=&quot;white&quot;, size=9, vjust=0.5), ggtheme = theme_pubr())+ geom_line(yintercept=0, linetype=2, color=&quot;lightgray&quot;) ###Cleveland点图1234ggdotchart(df2, x=&quot;name&quot;, y=&quot;mpg&quot;, color = &quot;cyl&quot;, palette = c(&quot;#00AFBB&quot;, &quot;#E7B800&quot;, &quot;#FC4E07&quot;), sorting = &quot;descending&quot;, rotate = TRUE, dot.size = 2, y.text.col=TRUE, ggtheme = theme_pubr())+ theme_cleveland() #SessionInfo1sessionInfo() 12345678910111213141516171819202122232425262728## R version 3.4.0 (2017-04-21)## Platform: x86_64-w64-mingw32/x64 (64-bit)## Running under: Windows 8.1 x64 (build 9600)## ## Matrix products: default## ## locale:## [1] LC_COLLATE=Chinese (Simplified)_China.936 ## [2] LC_CTYPE=Chinese (Simplified)_China.936 ## [3] LC_MONETARY=Chinese (Simplified)_China.936## [4] LC_NUMERIC=C ## [5] LC_TIME=Chinese (Simplified)_China.936 ## ## attached base packages:## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages:## [1] ggpubr_0.1.3 magrittr_1.5 ggplot2_2.2.1## ## loaded via a namespace (and not attached):## [1] Rcpp_0.12.11 knitr_1.16 munsell_0.4.3 colorspace_1.3-2## [5] R6_2.2.1 rlang_0.1.1 stringr_1.2.0 plyr_1.8.4 ## [9] dplyr_0.5.0 tools_3.4.0 grid_3.4.0 gtable_0.2.0 ## [13] DBI_0.6-1 htmltools_0.3.6 yaml_2.1.14 lazyeval_0.2.0 ## [17] rprojroot_1.2 digest_0.6.12 assertthat_0.2.0 tibble_1.3.3 ## [21] ggsignif_0.2.0 ggsci_2.4 purrr_0.2.2.2 evaluate_0.10 ## [25] rmarkdown_1.5 labeling_0.3 stringi_1.1.5 compiler_3.4.0 ## [29] scales_0.4.1 backports_1.1.0]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>R&amp;ggpubr&amp;visualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R语言学习笔记之相关性矩阵分析及其可视化]]></title>
    <url>%2F2017%2F06%2F25%2FR%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%9B%B8%E5%85%B3%E6%80%A7%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90%E5%8F%8A%E5%85%B6%E5%8F%AF%E8%A7%86%E5%8C%96%2F</url>
    <content type="text"><![CDATA[计算相关矩阵R内置函数cor()可以用来计算相关系数：cor(x, method = c(&quot;pearson&quot;, &quot;kendall&quot;, &quot;spearman&quot;))，如果数据有缺失值，用cor(x, method = &quot;pearson&quot;, use = &quot;complete.obs&quot;)。 导入数据 如果数据格式是txt，用my_data &lt;- read.delim(file.choose()) csv则用my_data &lt;- read.csv(file.choose())导入。这里我们利用R内置数据集mtcars。 123data(mtcars)#加载数据集mydata &lt;- mtcars[, c(1,3,4,5,6,7)]head(mydata, 6)#查看数据前6行 计算相关系数矩阵12res &lt;- cor(mydata)round(res, 2)#保留两位小数 cor()只能计算出相关系数，无法给出显著性水平p-value,Hmisc包里的rcorr()函数能够同时给出相关系数以及显著性水平p-value。rcorr(x, type = c(“pearson”,“spearman”))。 The output of the function rcorr() is a list containing the following elements : - r : the correlation matrix - n : the matrix of the number of observations used in analyzing each pair of variables - P : the p-values corresponding to the significance levels of correlations. 123library(Hmisc)#加载包res2 &lt;- rcorr(as.matrix(mydata))res2 12#可以用res2$r、res2$P来提取相关系数以及显著性p-valueres2$r 1res2$P 如何将相关系数以及显著性水平p-value整合进一个矩阵内，可以自定义一个函数flattenCorrMatrix。 12345678910111213# ++++++++++++++++++++++++++++# flattenCorrMatrix# ++++++++++++++++++++++++++++# cormat : matrix of the correlation coefficients# pmat : matrix of the correlation p-valuesflattenCorrMatrix &lt;- function(cormat, pmat) &#123;ut &lt;- upper.tri(cormat) data.frame( row = rownames(cormat)[row(cormat)[ut]], column = rownames(cormat)[col(cormat)[ut]], cor =(cormat)[ut], p = pmat[ut] )&#125;举个栗子---res3 &lt;- rcorr(as.matrix(mtcars[,1:7]))flattenCorrMatrix(res3$r, res3$P) 可视化相关系数矩阵有不同的方法来可视化，主要有下面四种： symnum() function corrplot() function to plot a correlogram scatter plots heatmap ##symnum() function主要用法：12symnum(x, cutpoints = c(0.3, 0.6, 0.8, 0.9, 0.95), symbols = c(&quot; “,”.“,”,“,”+“,”*“,”B“), abbr.colnames = TRUE) #很好理解，0-0.3用空格表示， 0.3-0.6用.表示， 以此类推。 举个栗子1symnum(res, abbr.colnames = FALSE)#abbr.colnames用来控制列名 ##corrplot() function to plot a correlogram这个函数来自于包corrplot(),通过颜色深浅来显著相关程度。参数主要有： type: “upper”, “lower”, “full”,显示上三角还是下三角还是全部 order:用什么方法，这里是hclust tl.col (for text label color) and tl.srt (for text label string rotation) :控制文本颜色以及旋转角度12library(corrplot)#先加载包corrplot(res, type = &quot;upper&quot;, order = &quot;hclust&quot;, tl.col = &quot;black&quot;, tl.srt = 45) ##也可以结合显著性绘制12# Insignificant correlations are leaved blankcorrplot(res2$r, type=&quot;upper&quot;, order=&quot;hclust&quot;, p.mat = res2$P, sig.level = 0.01, insig = &quot;blank&quot;) ##Use chart.Correlation(): Draw scatter plotschart.Correlation()来自于包PerformanceAnalytics12library(PerformanceAnalytics)#加载包chart.Correlation(mydata, histogram=TRUE, pch=19) 解释一下上图： 对角线上显示的是分布图 左下部显示的是具有拟合线的双变量散点图 右上部显示的是相关系数以及显著性水平 ##heatmap()12col&lt;- colorRampPalette(c(&quot;blue&quot;, &quot;white&quot;, &quot;red&quot;))(20)#调用颜色版自定义颜色heatmap(x = res, col = col, symm = TRUE)#symm表示是否对称 联系方式：wechat: yt056410Email: tyan@zju.edu.cnQQ: 1051927088GitHub: https://github.com/YTLogos简书: http://www.jianshu.com/u/bd001545cf0b博客: https://ytlogos.github.io/ 个人简介：严涛浙江大学作物遗传育种在读研究生（生物信息学方向）伪码农，R语言爱好者，爱开源]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>R&amp;corrplot&amp;visualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用circlize包绘制circos-plot]]></title>
    <url>%2F2017%2F06%2F25%2F%E7%94%A8circlize%E5%8C%85%E7%BB%98%E5%88%B6circos-plot%2F</url>
    <content type="text"><![CDATA[circlize包circlize包在德国癌症中心的华人博士Zuguang Gu开发的，有兴趣的可以去看看他的Github主页。这个包有两个文档，一个是介绍基本原理的绘制简单圈圈图的，也是本次要介绍的。另外一份文档专门介绍基因组数据绘制圈圈图Genomic Circos Plot,我自己还没看完，下次再介绍。根据我的学习发现这个包与ggplot2很相似，也是先创建一个图层，然后不断的添加图形元素（point、line、bar等），这些简单的图形元素都有circos.这个前缀进行绘制，比如要绘制点，则用circos.points()。具体的下面一一介绍。 #用circlize绘制圈圈图 照例，没有安装这个包的先安装：install.packages(&quot;circlize&quot;)或者devtools::install_github(&quot;jokergoo/circlize&quot;)。绘图第一步是先初始化(circos.initialize),接下来绘制track，再添加基本元素。需要提一下的是，由于circlize绘制图是不断叠加的，因此如果我们一大段代码下来我们只能看到最终的图形，这里为了演示每端代码的结果，所以每次我都得初始化以及circlize.clear。 ##绘制第一个track1234567891011par(mar = c(1, 1, 1, 1), lwd = 0.1, cex = 0.6)circos.par(track.height = 0.1)circos.initialize(factors = a$factors, x = a$x) #初始化，factors来控制track数目，初始化里只有x， 没有y。这一步相当于ggplot()circos.trackPlotRegion(factors = a$factors, y = a$y, panel.fun = function(x, y) &#123; circos.axis()&#125;)col &lt;- rep(c(&quot;#FF0000&quot;, &quot;#00FF00&quot;), 4) #自定义一下颜色# 这里先解释一下，一个track有好几个cell，具体数目由factors决定的，向本数据集中factors有八个，因此绘制一个track，其包含八个cell。含有前缀circos.track的函数会在所有的cel里添加基本元素，而只有前缀circos.的函数可以在特定的track、cell里添加基本元素。具体看下演示。circos.trackPoints(a$factors, a$x, a$y, col = col, pch = 16, cex = 0.5) #所有的cell里都绘制点图circos.text(-1, 0.5, &quot;left&quot;, sector.index = &quot;a&quot;, track.index = 1) #在track 1中的标记为a的cell里添加textcircos.text(1, 0.5, &quot;right&quot;, sector.index = &quot;a&quot;)circos.clear() ##接下来绘制第二个track circos.trackHist添加柱状图，由于柱状图相对高级一点，因此circos.trackHist会自动创建一个track，无需我们circos.trackPlotRegion进行创建。 12345678910111213par(mar = c(1, 1, 1, 1), lwd = 0.1, cex = 0.6)circos.par(track.height = 0.1)circos.initialize(factors = a$factors, x = a$x)circos.trackPlotRegion(factors = a$factors, y = a$y, panel.fun = function(x, y) &#123; circos.axis()&#125;)col &lt;- rep(c(&quot;#FF0000&quot;, &quot;#00FF00&quot;), 4)circos.trackPoints(a$factors, a$x, a$y, col = col, pch = 16, cex = 0.5)circos.text(-1, 0.5, &quot;left&quot;, sector.index = &quot;a&quot;, track.index = 1)circos.text(1, 0.5, &quot;right&quot;, sector.index = &quot;a&quot;)bg.col &lt;- rep(c(&quot;#EFEFEF&quot;, &quot;#CCCCCC&quot;), 4)circos.trackHist(a$factors, a$x, bg.col = bg.col, col = NA)circos.clear() ##创建第三个track 这里又得提一下，当我们绘制多个track时，我们添加基本元素时要指定添加到哪个track(track.index指定)、哪个cell(sector.index指定)里，如果不指定，那么将默认track是我们刚刚创建的那个。track.index、sector.index等参数可以通过get.cell.meta.data函数获取。 12345678910111213141516171819202122par(mar = c(1, 1, 1, 1), lwd = 0.1, cex = 0.6)circos.par(track.height = 0.1)circos.initialize(factors = a$factors, x = a$x)circos.trackPlotRegion(factors = a$factors, y = a$y, panel.fun = function(x, y) &#123; circos.axis()&#125;)col &lt;- rep(c(&quot;#FF0000&quot;, &quot;#00FF00&quot;), 4)circos.trackPoints(a$factors, a$x, a$y, col = col, pch = 16, cex = 0.5)circos.text(-1, 0.5, &quot;left&quot;, sector.index = &quot;a&quot;, track.index = 1)circos.text(1, 0.5, &quot;right&quot;, sector.index = &quot;a&quot;)bg.col &lt;- rep(c(&quot;#EFEFEF&quot;, &quot;#CCCCCC&quot;), 4)circos.trackHist(a$factors, a$x, bg.col = bg.col, col = NA)circos.trackPlotRegion(factors = a$factors, x = a$x, y = a$y, panel.fun = function(x, y) &#123; grey = c(&quot;#FFFFFF&quot;, &quot;#CCCCCC&quot;, &quot;#999999&quot;) sector.index = get.cell.meta.data(&quot;sector.index&quot;) #这个是第三个track，因为我们刚刚创建，这里这一步不用也可。 xlim = get.cell.meta.data(&quot;xlim&quot;) ylim = get.cell.meta.data(&quot;ylim&quot;) circos.text(mean(xlim), mean(ylim), sector.index) circos.points(x[1:10], y[1:10], col = &quot;red&quot;, pch = 16, cex = 0.6) circos.points(x[11:20], y[11:20], col = &quot;blue&quot;, cex = 0.6)&#125;)circos.clear() 实际操作中我们常常会更新数据或者想更新图形，这是可以通过circos.updatePlotRegion函数在特定的track、cell里(先删除再添加)update，下面我们将通过circos.updatePlotRegion函数先删除track 2、sector d中的图形元素再添加点图。 123456789101112131415161718192021222324252627282930par(mar = c(1, 1, 1, 1), lwd = 0.1, cex = 0.6)circos.par(track.height = 0.1)circos.initialize(factors = a$factors, x = a$x)circos.trackPlotRegion(factors = a$factors, y = a$y, panel.fun = function(x, y) &#123; circos.axis()&#125;)col &lt;- rep(c(&quot;#FF0000&quot;, &quot;#00FF00&quot;), 4)circos.trackPoints(a$factors, a$x, a$y, col = col, pch = 16, cex = 0.5)circos.text(-1, 0.5, &quot;left&quot;, sector.index = &quot;a&quot;, track.index = 1)circos.text(1, 0.5, &quot;right&quot;, sector.index = &quot;a&quot;)circos.trackPoints(a$factors, a$x, a$y, col = col, pch = 16, cex = 0.5)circos.text(-1, 0.5, &quot;left&quot;, sector.index = &quot;a&quot;, track.index = 1)circos.text(1, 0.5, &quot;right&quot;, sector.index = &quot;a&quot;)bg.col &lt;- rep(c(&quot;#EFEFEF&quot;, &quot;#CCCCCC&quot;), 4)circos.trackHist(a$factors, a$x, bg.col = bg.col, col = NA)circos.trackPlotRegion(factors = a$factors, x = a$x, y = a$y, panel.fun = function(x, y) &#123; grey = c(&quot;#FFFFFF&quot;, &quot;#CCCCCC&quot;, &quot;#999999&quot;) sector.index = get.cell.meta.data(&quot;sector.index&quot;) xlim = get.cell.meta.data(&quot;xlim&quot;) ylim = get.cell.meta.data(&quot;ylim&quot;) circos.text(mean(xlim), mean(ylim), sector.index)circos.points(x[1:10], y[1:10], col = &quot;red&quot;, pch = 16, cex = 0.6) circos.points(x[11:20], y[11:20], col = &quot;blue&quot;, cex = 0.6)&#125;)# update第2个track中标记为d的sectorcircos.updatePlotRegion(sector.index = &quot;d&quot;, track.index = 2)circos.points(x = -2:2, y = rep(0, 5))xlim &lt;- get.cell.meta.data(&quot;xlim&quot;)ylim &lt;- get.cell.meta.data(&quot;ylim&quot;)circos.text(mean(xlim), mean(ylim), &quot;updated&quot;)circos.clear() ##接下来绘制第四个track1234567891011121314151617181920212223242526272829303132par(mar = c(1, 1, 1, 1), lwd = 0.1, cex = 0.6)circos.par(track.height = 0.1)circos.initialize(factors = a$factors, x = a$x)circos.trackPlotRegion(factors = a$factors, y = a$y, panel.fun = function(x, y) &#123; circos.axis()&#125;)col &lt;- rep(c(&quot;#FF0000&quot;, &quot;#00FF00&quot;), 4)circos.trackPoints(a$factors, a$x, a$y, col = col, pch = 16, cex = 0.5)circos.text(-1, 0.5, &quot;left&quot;, sector.index = &quot;a&quot;, track.index = 1)circos.text(1, 0.5, &quot;right&quot;, sector.index = &quot;a&quot;)circos.trackPoints(a$factors, a$x, a$y, col = col, pch = 16, cex = 0.5)circos.text(-1, 0.5, &quot;left&quot;, sector.index = &quot;a&quot;, track.index = 1)circos.text(1, 0.5, &quot;right&quot;, sector.index = &quot;a&quot;)bg.col &lt;- rep(c(&quot;#EFEFEF&quot;, &quot;#CCCCCC&quot;), 4)circos.trackHist(a$factors, a$x, bg.col = bg.col, col = NA)circos.trackPlotRegion(factors = a$factors, x = a$x, y = a$y, panel.fun = function(x, y) &#123; grey = c(&quot;#FFFFFF&quot;, &quot;#CCCCCC&quot;, &quot;#999999&quot;) sector.index = get.cell.meta.data(&quot;sector.index&quot;) xlim = get.cell.meta.data(&quot;xlim&quot;) ylim = get.cell.meta.data(&quot;ylim&quot;) circos.text(mean(xlim), mean(ylim), sector.index) circos.points(x[1:10], y[1:10], col = &quot;red&quot;, pch = 16, cex = 0.6) circos.points(x[11:20], y[11:20], col = &quot;blue&quot;, cex = 0.6)&#125;)# update第2个track中标记为d的sectorcircos.updatePlotRegion(sector.index = &quot;d&quot;, track.index = 2)circos.points(x = -2:2, y = rep(0, 5))xlim &lt;- get.cell.meta.data(&quot;xlim&quot;)ylim &lt;- get.cell.meta.data(&quot;ylim&quot;)circos.text(mean(xlim), mean(ylim), &quot;updated&quot;)circos.clear()circos.trackPlotRegion(factors = a$factors, y = a$y)circos.trackLines(a$factors[1:100], a$x[1:100], a$y[1:100], type = &quot;h&quot;) 接下来添加links，links可以是point到point、point到interval、interval到interval 1234567891011121314151617181920212223242526272829303132333435par(mar = c(1, 1, 1, 1), lwd = 0.1, cex = 0.6)circos.par(track.height = 0.1)circos.initialize(factors = a$factors, x = a$x)circos.trackPlotRegion(factors = a$factors, y = a$y, panel.fun = function(x, y) &#123; circos.axis()&#125;)col &lt;- rep(c(&quot;#FF0000&quot;, &quot;#00FF00&quot;), 4)circos.trackPoints(a$factors, a$x, a$y, col = col, pch = 16, cex = 0.5)circos.text(-1, 0.5, &quot;left&quot;, sector.index = &quot;a&quot;, track.index = 1)circos.text(1, 0.5, &quot;right&quot;, sector.index = &quot;a&quot;)circos.trackPoints(a$factors, a$x, a$y, col = col, pch = 16, cex = 0.5)circos.text(-1, 0.5, &quot;left&quot;, sector.index = &quot;a&quot;, track.index = 1)circos.text(1, 0.5, &quot;right&quot;, sector.index = &quot;a&quot;)bg.col &lt;- rep(c(&quot;#EFEFEF&quot;, &quot;#CCCCCC&quot;), 4)circos.trackHist(a$factors, a$x, bg.col = bg.col, col = NA)circos.trackPlotRegion(factors = a$factors, x = a$x, y = a$y, panel.fun = function(x, y) &#123; grey = c(&quot;#FFFFFF&quot;, &quot;#CCCCCC&quot;, &quot;#999999&quot;) sector.index = get.cell.meta.data(&quot;sector.index&quot;) xlim = get.cell.meta.data(&quot;xlim&quot;) ylim = get.cell.meta.data(&quot;ylim&quot;)circos.text(mean(xlim), mean(ylim), sector.index) circos.points(x[1:10], y[1:10], col = &quot;red&quot;, pch = 16, cex = 0.6) circos.points(x[11:20], y[11:20], col = &quot;blue&quot;, cex = 0.6)&#125;)# update第2个track中标记为d的sectorcircos.updatePlotRegion(sector.index = &quot;d&quot;, track.index = 2)circos.points(x = -2:2, y = rep(0, 5))xlim &lt;- get.cell.meta.data(&quot;xlim&quot;)ylim &lt;- get.cell.meta.data(&quot;ylim&quot;)circos.text(mean(xlim), mean(ylim), &quot;updated&quot;)circos.clear()circos.trackPlotRegion(factors = a$factors, y = a$y)circos.trackLines(a$factors[1:100], a$x[1:100], a$y[1:100], type = &quot;h&quot;)circos.link(&quot;a&quot;, 0, &quot;b&quot;, 0, h = 0.3) #point to pointcircos.link(&quot;c&quot;, c(-0.5, 0.5), &quot;d&quot;, c(-0.5, 0.5), col = &quot;red&quot;, border = NA, h = 0.2) #intreval to intervalcircos.link(&quot;e&quot;, 0, &quot;g&quot;, c(-1, 1), col = &quot;green&quot;, border = &quot;black&quot;, lwd = 2, lty = 2) #point to interval #circlize详述 circlize的绘图规则是初始化(initialize)-创建track-添加图形元素-创建track-添加图形元素-…-circos.clear。具体参数设置以及解释由于内容太多，有兴趣的可以自己参考文档。 我认为比较重要的是要理解track、sector。由于基本所有的图形元素我们都是添加在sector里面，因此就需要指定track.index以及sector.index。接下来就用个例子来讲解一下如何操纵track、sector。 12345678910par(mar = c(1, 1, 1, 1))factors &lt;- letters[1:8]circos.initialize(factors = factors, xlim = c(0, 1)) #初始化# 绘制三个track，并显示具体信息for (i in 1:3) &#123; circos.trackPlotRegion(ylim = c(0, 1))&#125;circos.info(plot = TRUE)# 通过draw.sector()来高亮某一sector，比如a：draw.sector(get.cell.meta.data(&quot;cell.start.degree&quot;, sector.index = &quot;a&quot;), get.cell.meta.data(&quot;cell.end.degree&quot;, sector.index = &quot;a&quot;), rou1 = 1, col = &quot;blue&quot;)circos.clear() 12345678# 高亮某一track， 比如第一个track：circos.initialize(factors = factors, xlim = c(0, 1))for (i in 1:3) &#123; circos.trackPlotRegion(ylim = c(0, 1))&#125;circos.info(plot = TRUE)draw.sector(0, 360, rou1 = get.cell.meta.data(&quot;cell.top.radius&quot;, track.index = 1), rou2 = get.cell.meta.data(&quot;cell.bottom.radius&quot;, track.index = 1), col = &quot;green&quot;)circos.clear() 123456789# 高亮某一track某一sector，比如地2、3track中的e、f(sector)：circos.initialize(factors = factors, xlim = c(0, 1))for (i in 1:3) &#123; circos.trackPlotRegion(ylim = c(0, 1))&#125;circos.info(plot = TRUE)draw.sector(get.cell.meta.data(&quot;cell.start.degree&quot;, sector.index = &quot;e&quot;), get.cell.meta.data(&quot;cell.end.degree&quot;, sector.index = &quot;f&quot;), get.cell.meta.data(&quot;cell.top.radius&quot;, track.index = 2), get.cell.meta.data(&quot;cell.bottom.radius&quot;, track.index = 3), col = &quot;red&quot;)circos.clear() #千万别忘了circos.clear，不然下次无法绘图。 #放大某一特定区域123456789101112131415161718192021222324252627df &lt;- data.frame(factors = sample(letters[1:6], 100, replace = TRUE), x = rnorm(100), y = rnorm(100), stringsAsFactors = FALSE)# 放大a，b区域zoom_df &lt;- df %&gt;% dplyr::filter(factors %in% c(&quot;a&quot;, &quot;b&quot;))zoom_df$factors &lt;- paste0(&quot;zoom_&quot;, zoom_df$factors)df2 &lt;- rbind(df, zoom_df)xrange &lt;- tapply(df2$x, df2$factors, function(x) max(x) - min(x))normal_sector_index &lt;- unique(df$factors)zoomed_sector_index &lt;- unique(zoom_df$factors)sector.width &lt;- c(xrange[normal_sector_index]/sum(xrange[normal_sector_index]), xrange[zoomed_sector_index]/sum(xrange[zoomed_sector_index]))# 绘图par(mar = c(1, 1, 1, 1))circos.par(start.degree = 90)circos.initialize(df2$factors, x = df2$x, sector.width = sector.width)circos.trackPlotRegion(df2$factors, x = df2$x, y = df2$y, panel.fun = function(x, y) &#123; circos.points(x, y, col = &quot;red&quot;, pch = 16, cex = 0.5) xlim = get.cell.meta.data(&quot;xlim&quot;) ylim = get.cell.meta.data(&quot;ylim&quot;) sector.index = get.cell.meta.data(&quot;sector.index&quot;) circos.text(mean(xlim), mean(ylim), sector.index, niceFacing = TRUE)&#125;)# 添加linkscircos.link(&quot;a&quot;, get.cell.meta.data(&quot;cell.xlim&quot;, sector.index = &quot;a&quot;), &quot;zoom_a&quot;, get.cell.meta.data(&quot;cell.xlim&quot;, sector.index = &quot;zoom_a&quot;), border = NA, col = &quot;red&quot;) circos.clear() #举个栗子 圈圈图+热图+进化树 1234567891011121314151617181920212223242526272829set.seed(1234)data &lt;- matrix(rnorm(100 * 10), nrow = 10, ncol = 100)col &lt;- colorRamp2(c(-2, 0, 2), c(&quot;green&quot;, &quot;black&quot;, &quot;red&quot;))factors &lt;- rep(letters[1:2], times = c(30, 70))data_list &lt;- list(a = data[, factors == &quot;a&quot;], b = data[, factors == &quot;b&quot;])dend_list &lt;- list(a = as.dendrogram(hclust(dist(t(data_list[[&quot;a&quot;]])))), b = as.dendrogram(hclust(dist(t(data_list[[&quot;b&quot;]])))))circos.par(cell.padding = c(0, 0, 0, 0), gap.degree = 5)circos.initialize(factors = factors, xlim = cbind(c(0, 0), table(factors)))circos.track(ylim = c(0, 10), bg.border = NA, panel.fun = function(x, y) &#123; sector.index = get.cell.meta.data(&quot;sector.index&quot;) d = data_list[[sector.index]] dend = dend_list[[sector.index]] d2 = d[, order.dendrogram(dend)] col_data = col(d2)nr = nrow(d2)nc = ncol(d2) for (i in 1:nr) &#123; circos.rect(1:nc - 1, rep(nr - i, nc), 1:nc, rep(nr - i + 1, nc),border = col_data[i, ], col = col_data[i, ]) &#125;&#125;)max_height &lt;- max(sapply(dend_list, function(x) attr(x, &quot;height&quot;)))circos.track(ylim = c(0, max_height), bg.border = NA, track.height = 0.3,panel.fun = function(x, y) &#123; sector.index = get.cell.meta.data(&quot;sector.index&quot;)dend = dend_list[[sector.index]]circos.dendrogram(dend, max_height = max_height)&#125;)circos.clear() #多图排列 直接用layout设置 123456789101112131415layout(matrix(1:9, 3, 3))for (i in 1:9) &#123; factors = letters[1:8] par(mar = c(0.5, 0.5, 0.5, 0.5)) circos.par(cell.padding = c(0, 0, 0, 0)) circos.initialize(factors = factors, xlim = c(0, 1)) circos.trackPlotRegion(ylim = c(0, 1), track.height = 0.05, bg.col = rand_color(8), bg.border = NA) # 绘制links for (i in 1:20) &#123;se = sample(letters[1:8], 2) circos.link(se[1], runif(2), se[2], runif(2),col = rand_color(1, transparency = 0.4), border = NA) &#125; circos.clear() #sessionInfo 理解circlize包的原理，绘制基因组数据的图形也是一样的。有时间下次介绍(主要是我自己还没看完，看不太懂)。老规矩，给出sessionInfo。1sessionInfo() 1234567891011121314151617181920212223242526272829303132333435## R version 3.4.0 (2017-04-21)## Platform: x86_64-w64-mingw32/x64 (64-bit)## Running under: Windows 8.1 x64 (build 9600)## ## Matrix products: default## ## locale:## [1] LC_COLLATE=Chinese (Simplified)_China.936 ## [2] LC_CTYPE=Chinese (Simplified)_China.936 ## [3] LC_MONETARY=Chinese (Simplified)_China.936## [4] LC_NUMERIC=C ## [5] LC_TIME=Chinese (Simplified)_China.936 ## ## attached base packages:## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages:## [1] circlize_0.4.0 BiocInstaller_1.26.0 forcats_0.2.0## [4] stringr_1.2.0 dplyr_0.5.0 purrr_0.2.2.2 ## [7] readr_1.1.1 tidyr_0.6.3 tibble_1.3.1## [10] ggplot2_2.2.1 tidyverse_1.1.1.9000#### loaded via a namespace (and not attached):## [1] shape_1.4.2 clisymbols_1.2.0 reshape2_1.4.2 ## [4] haven_1.0.0 lattice_0.20-35 colorspace_1.3-2## [7] htmltools_0.3.6 yaml_2.1.14 rlang_0.1.1 ## [10] foreign_0.8-68 DBI_0.6-1 modelr_0.1.0## [13] readxl_1.0.0 plyr_1.8.4 munsell_0.4.3 ## [16] gtable_0.2.0 cellranger_1.1.0 rvest_0.3.2 ## [19] GlobalOptions_0.0.12 psych_1.7.5 evaluate_0.10 ## [22] knitr_1.16 parallel_3.4.0 broom_0.4.2 ## [25] Rcpp_0.12.11 scales_0.4.1 backports_1.1.0 ## [28] formatR_1.5 jsonlite_1.4 boxes_0.0.0.9000## [31] mnormt_1.5-5 hms_0.3 digest_0.6.12 ## [34] stringi_1.1.5 grid_3.4.0 rprojroot_1.2## [37] tools_3.4.0 magrittr_1.5 lazyeval_0.2.0 ## [40] crayon_1.3.2.9000 xml2_1.1.1 lubridate_1.6.0 ## [43] assertthat_0.2.0 rmarkdown_1.5 httr_1.2.1 ## [46] rstudioapi_0.6 R6_2.2.1 nlme_3.1-131## [49] compiler_3.4.0]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>R&amp;circlize&amp;visualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ggplot2学习笔记系列之利用ggplot2绘制误差棒及显著性标记]]></title>
    <url>%2F2017%2F06%2F25%2Fggplot2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%A9%E7%94%A8ggplot2%E7%BB%98%E5%88%B6%E8%AF%AF%E5%B7%AE%E6%A3%92%E5%8F%8A%E6%98%BE%E8%91%97%E6%80%A7%E6%A0%87%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[绘制带有误差棒的条形图 123456789101112131415library(ggplot2)# 创建数据集df &lt;- data.frame(treatment = factor(c(1, 1, 1, 2, 2, 2, 3, 3, 3)), response = c(2, 5, 4, 6, 9, 7, 3, 5, 8), group = factor(c(1, 2, 3, 1, 2, 3, 1, 2, 3)), se = c(0.4, 0.2, 0.4, 0.5, 0.3, 0.2, 0.4, 0.6, 0.7))head(df) #查看数据集## treatment response group se## 1 1 2 1 0.4## 2 1 5 2 0.2## 3 1 4 3 0.4## 4 2 6 1 0.5## 5 2 9 2 0.3## 6 2 7 3 0.2 12345678# 使用geom_errorbar()绘制带有误差棒的条形图# 这里一定要注意position要与`geom_bar()`保持一致，由于系统默认dodge是0.9，# 因此geom_errorbar()里面position需要设置0.9，width设置误差棒的大小ggplot(data = df, aes(x = treatment, y = response, fill = group)) + geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;) + geom_errorbar(aes(ymax = response + se, ymin = response - se), position = position_dodge(0.9), width = 0.15) + scale_fill_brewer(palette = &quot;Set1&quot;) #绘制带有显著性标记的条形图123456789label &lt;- c(&quot;&quot;, &quot;*&quot;, &quot;**&quot;, &quot;&quot;, &quot;**&quot;, &quot;*&quot;, &quot;&quot;, &quot;&quot;, &quot;*&quot;) #这里随便设置的显著性，还有abcdef等显著性标记符号，原理一样，这里不再重复。# 添加显著性标记跟上次讲的添加数据标签是一样的，这里我们假设1是对照ggplot(data = df, aes(x = treatment, y = response, fill = group)) + geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;) + geom_errorbar(aes(ymax = response + se, ymin = response - se), position = position_dodge(0.9), width = 0.15) + geom_text(aes(y = response + 1.5 * se, label = label, group = group), position = position_dodge(0.9), size = 5, fontface = &quot;bold&quot;) + scale_fill_brewer(palette = &quot;Set1&quot;) #这里的label就是刚才设置的，group是数据集中的，fontface设置字体。 #绘制两条形图中间带有星号的统计图12345678910111213141516#创建一个简单的数据集Control &lt;- c(2.0,2.5,2.2,2.4,2.1)Treatment &lt;- c(3.0,3.3,3.1,3.2,3.2)mean &lt;- c(mean(Control), mean(Treatment))sd &lt;- c(sd(Control), sd(Treatment))df1 &lt;- data.frame(V=c(&quot;Control&quot;, &quot;Treatment&quot;), mean=mean, sd=sd)df1$V &lt;- factor(df1$V, levels=c(&quot;Control&quot;, &quot;Treatment&quot;))#利用geom_segment()绘制图形ggplot(data=df1, aes(x=V, y=mean, fill=V))+ geom_bar(stat = &quot;identity&quot;,position = position_dodge(0.9),color=&quot;black&quot;)+ geom_errorbar(aes(ymax=mean+sd, ymin=mean-sd), width=0.05)+ geom_segment(aes(x=1, y=2.5, xend=1, yend=3.8))+#绘制control端的竖线 geom_segment(aes(x=2, y=3.3, xend=2, yend=3.8))+#绘制treatment端竖线 geom_segment(aes(x=1, y=3.8, xend=1.45, yend=3.8))+ geom_segment(aes(x=1.55, y=3.8, xend=2, yend=3.8))+#绘制两段横线 annotate(&quot;text&quot;, x=1.5, y=3.8, label=&quot;〇&quot;, size=5)#annotate函数也可以添加标签 #为图形添加标题图形标题有图标题、坐标轴标题、图例标题等123456p &lt;- ggplot(data = df, aes(x = treatment, y = response, fill = group)) + geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;) +geom_errorbar(aes(ymax = response + se, ymin = response - se),position = position_dodge(0.9), width = 0.15) + scale_fill_brewer(palette = &quot;Set1&quot;)# 利用ggtitle()添加图标题,还有labs（）也可以添加标题，最后会提一下。（有一个问题就是ggtitle()添加的标题总是左对齐）p + ggtitle(&quot;利用ggtitle()添加图标题&quot;) 1234# 利用xlab()\ylab()添加/修改坐标轴标题p + ggtitle(&quot;利用ggtitle()添加图标题&quot;) + xlab(&quot;不同处理&quot;) + ylab(&quot;response&quot;) #标题的参数修改在theme里，theme是一个很大的函数，几乎可以定义一切，下次有时间会讲解 最后再讲解一下如何将多副图至于一个页面 利用包gridExtra中grid.arrange()函数实现1234567891011121314151617# 将四幅图放置于一个页面中p &lt;- ggplot(data = df, aes(x = treatment, y = response, fill = group)) + geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;) + geom_errorbar(aes(ymax = response + se, ymin = response - se), position = position_dodge(0.9), width = 0.15) + scale_fill_brewer(palette = &quot;Set1&quot;)p1 &lt;- p + ggtitle(&quot;利用ggtitle()添加图标题&quot;)p2 &lt;- p + ggtitle(&quot;利用ggtitle()添加图标题&quot;) + xlab(&quot;不同处理&quot;) + ylab(&quot;response&quot;)p3 &lt;- ggplot(data = df, aes(x = treatment, y = response, fill = group)) + geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;) + geom_errorbar(aes(ymax = response + se, ymin = response - se), position = position_dodge(0.9), width = 0.15) + geom_text(aes(y = response + 1.5 * se, label = label, group = group), position = position_dodge(0.9), size = 5, fontface = &quot;bold&quot;) + scale_fill_brewer(palette = &quot;Set1&quot;)library(gridExtra) #没有安装此包先用install.packages(&apos;gridExtra&apos;)安装grid.arrange(p, p1, p2, p3) 上次有人问坐标轴旋转的实现，坐标轴旋转有时是很有用的，下面是我看过的一个例子，用来介绍一下。1234#先加载他的数据url.world_ports &lt;- url(&quot;http://sharpsightlabs.com/wp-content/datasets/world_ports.RData&quot;)load(url.world_ports)knitr::kable(df.world_ports[1:5,])#该数据是关于世界上各个港口的数据汇总 12345678library(dplyr) #用于数据操作，与ggplot2一样是R语言必学包#现在绘制条形图(%&gt;%上次说过是管道操作，用于连接各个代码，十分有用)df.world_ports%&gt;%filter(year==2014)%&gt;% #筛选2014年的数据 ggplot(aes(x=reorder(port_label, desc(volume)), y=volume))+ geom_bar(stat = &quot;identity&quot;, fill=&quot;darkred&quot;)+ labs(title=&quot;Busiest container ports in the world&quot;)+ labs(subtitle = &apos;2014, in order of shipping volume&apos;)+ #添加副标题 labs(x = &quot;Port&quot;, y = &quot;Shipping\nVolume&quot;)+ theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = .4))#调整x轴标签，angle=90表示标签旋转90度，从图中可以看出 123456789#现在旋转坐标轴，并筛选排名小于25的港口，并且添加数据标签df.world_ports %&gt;% filter(year==2014, rank&lt;=25) %&gt;% #筛选2014年并且rank小于等于25的数据 ggplot(aes(x=reorder(port, volume), y=volume))+ geom_bar(stat = &quot;identity&quot;, fill=&quot;darkred&quot;)+ labs(title=&quot;Busiest container ports in the world&quot;)+ labs(subtitle = &apos;2014, in order of shipping volume&apos;)+ labs(x = &quot;Port&quot;, y = &quot;Shipping\nVolume&quot;)+ geom_text(aes(label=volume), hjust=1.2, color=&quot;white&quot;)+ coord_flip()#旋转坐标轴 两图相比，明显第二幅图好，一是可以添加数据标签，二是不用歪着脖子看。本来打算讲讲图例的但是发现内容太多了，就不讲了，下次吧！]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>R&amp;ggplot2&amp;visualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ggplot2学习笔记系列之利用ggplot2绘制条形图]]></title>
    <url>%2F2017%2F06%2F25%2Fggplot2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%A9%E7%94%A8ggplot2%E7%BB%98%E5%88%B6%E6%9D%A1%E5%BD%A2%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[简介条形图可以说是我们最常用的数据可视化方法了，通常用于展示不同分类条件下（在x轴上）某个数值型变量的取值（y轴上）。绘制条形图时需要特别注意的一个细节是条形图的条形高度有时表示的是数据集中变量的频数，有时表示的则是变量本身。本文将会介绍这两类条形图的绘图技巧。 #绘制条形图使用ggplot()函数与geom_bar(stat=&quot;identity&quot;)，绘制条形图，我们将利用gcookbook包中的数据进行绘制。12345678910#没安装包要先安装包gcookbook、ggplot2以及dplyrlibrary(gcookbook)#加载gcookbook以使用其包含的数据library(ggplot2)#用于可视化library(dplyr)#用于数据处理这里我们调用**gcookbook**里的数据集绘制条形图head(pg_mean)#查看数据集## group weigh 1 ctrl 5.032 2 trt1 4.661 3 trt2 5.526 123ggplot(data=pg_mean, aes(x=group, y=weight))+#将group、weight分别赋值给x、y轴 geom_bar(stat = &quot;identity&quot;)#必须将geom_bar()中的stat(统计变换)参数设置为”identity“，即对原始数据集不作任何统计变换，而该参数的默认值为&apos;count&apos;，即观测数量。 当x是连续型（数值型）变量时，条形图略有不同，需要略作调整，具体如下：123456str(BOD)#查看BOD数据集可以发现Time变量是数值型## &apos;data.frame&apos;: 6 obs. of 2 variables: ## $ Time : num 1 2 3 4 5 7## $ demand: num 8.3 10.3 19 16 15.6 19.8## - attr(*, &quot;reference&quot;)= chr &quot;A1.4, p. 270&quot; 1ggplot(data=BOD, aes(x=Time, y=demand))+ geom_bar(stat = &quot;identity&quot;)#此时Time是数值型 12ggplot(data=BOD, aes(x=factor(Time), y=demand))+ geom_bar(stat = &quot;identity&quot;)#将Time转换为因子型（分类/离散变量），仔细比较两图 条形图颜色有两部分：填充颜色（fill）以及边框颜色（color），因此调整条形图颜色要调两部分，具体如下：12ggplot(data=BOD, aes(x=factor(Time), y=demand))+ geom_bar(stat = &quot;identity&quot;, fill=&quot;blue&quot;, color=&quot;black&quot;)#可以自己设定喜好的颜色 #绘制簇状条形图方法：将分类变量映射到fill参数，运用geom_bar(position=&quot;dodge&quot;)绘制，具体如下：123456789head(cabbage_exp)#查看数据，发现含有两个分类变量：`Cultivar`和`Date`以及一个连续型变量Weight## Cultivar Date Weight sd n se## 1 c39 d16 3.18 0.9566144 10 0.30250803## 2 c39 d20 2.80 0.2788867 10 0.08819171## 3 c39 d21 2.74 0.9834181 10 0.31098410## 4 c52 d16 2.26 0.4452215 10 0.14079141## 5 c52 d20 3.11 0.7908505 10 0.25008887## 6 c52 d21 1.47 0.2110819 10 0.06674995 12ggplot(data=cabbage_exp, aes(x=Date, y=Weight, fill=Cultivar))+#分别将Date与Cultivar映射给x和fill geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;)#position = &quot;dodge&quot;表示条形图分开不重叠(簇形图)，默认的为stack（堆叠式）,还有百分比堆叠式(fill) 12ggplot(data=cabbage_exp, aes(x=Date, y=Weight, fill=Cultivar))+geom_bar(stat = &quot;identity&quot;, position = &quot;stack&quot;)#堆叠式 12ggplot(data=cabbage_exp, aes(x=Date, y=Weight, fill=Cultivar))+ geom_bar(stat = &quot;identity&quot;, position = &quot;fill&quot;)#百分比堆叠式 #设置颜色或者调用调色板123ggplot(data=cabbage_exp, aes(x=Date, y=Weight, fill=Cultivar))+ geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;, color=&quot;black&quot;)+ scale_fill_brewer(palette = &quot;Set1&quot;)#Set1为调色板，后期将会专门讲解Color设置 123ggplot(data=cabbage_exp, aes(x=Date, y=Weight, fill=Cultivar))+ geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;, color=&quot;black&quot;)+ scale_fill_manual(values = c(&quot;darkred&quot;, &quot;purple&quot;))#自设置颜色 #绘制频数条形图123456789101112131415head(diamonds,n=10)#查看前10行数据## # A tibble: 10 × 10## carat cut color clarity depth table price x y z## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;## 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43## 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31## 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31## 4 0.29 Premium I VS2 62.4 58 334 4.20 4.23 2.63## 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75## 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48## 7 0.24 Very Good I VVS1 62.3 57 336 3.95 3.98 2.47## 8 0.26 Very Good H SI1 61.9 55 337 4.07 4.11 2.53## 9 0.22 Fair E VS2 65.1 61 337 3.87 3.78 2.49## 10 0.23 Very Good H VS1 59.4 61 338 4.00 4.05 2.39 12ggplot(diamonds, aes(x=cut))+#此时不要映射任何变量到y geom_bar()#等价于geom_bar(stat=&quot;bin&quot;) #绘制y轴正负轴都有数据的条形图12345678910111213#首先先创建一下数据集set.seed(1111)#此命令保证数据结果可以重现在任何电脑上x &lt;- 1980+1:36#赋值xy &lt;- round(100*rnorm(36))#赋值ymydata &lt;- data.frame(x=x, y=y)#创建数据集mydatahead(mydata)#查看数据集## x y## 1 1981 -9## 2 1982 132## 3 1983 64## 4 1984 117## 5 1985 12## 6 1986 -293 12345678910mydata &lt;- mydata%&gt;%#%&gt;%管道操作，结合dplyr为数据处理神器 mutate(judge=ifelse(y&gt;=0,&quot;Yes&quot;, &quot;No&quot;))#创建judge变量，将y正负分类head(mydata)#查看数据## x y judge## 1 1981 -9 No## 2 1982 132 Yes## 3 1983 64 Yes## 4 1984 117 Yes## 5 1985 12 Yes## 6 1986 -293 No 1234#接下来绘制条形图ggplot(data=mydata, aes(x=x, y=y, fill=judge))+ geom_bar(stat = &quot;identity&quot;,position = &quot;identity&quot;)+#这里position=&quot;identity&quot;可以避免系统对负值绘制条形图发出警告信息 scale_fill_manual(values = c(&quot;purple&quot;, &quot;blue&quot;), guide=FALSE)+xlab(&quot;Year&quot;)#guide=FALSE表示不要图例,x轴标题为Year #通过width来调整条形宽度以及条形距离1234567891011head(diamonds)## # A tibble: 6 × 10## carat cut color clarity depth table price x y z## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;## 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43## 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31## 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31## 4 0.29 Premium I VS2 62.4 58 334 4.20 4.23 2.63## 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75## 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 123ggplot(data=diamonds, aes(x=color, y=price, fill=cut))+ geom_bar(stat = &quot;identity&quot;, width = 0.6, position = position_dodge(0.8))+#调整条形宽度以及条形距离 scale_fill_brewer(palette = &quot;Set1&quot;) #geom_text()添加数据标签使用geom_text()为条形图添加标签，需要分别指定一个变量映射给x、y以及标签（label），vjust和hjust分别调整标签的竖直和水平位置。1234#标签在条形图顶端下方ggplot(data=cabbage_exp, aes(x=interaction(Date, Cultivar), y=Weight))+ geom_bar(stat = &quot;identity&quot;)+ geom_text(aes(label=Weight), vjust=1.5, color=&quot;white&quot;) 1234#标签在条形图顶端上方ggplot(data=cabbage_exp, aes(x=interaction(Date, Cultivar), y=Weight))+ geom_bar(stat = &quot;identity&quot;)+ geom_text(aes(label=Weight), vjust=-0.3, color=&quot;red&quot;)#可以通过color、size等自行调整标签属性 12345#堆叠图也一样ggplot(data=cabbage_exp, aes(x=Date, y=Weight, fill=Cultivar))+ geom_bar(stat=&quot;identity&quot;, position = &quot;stack&quot;)+ geom_text(aes(label=Weight), size=5, color=&quot;black&quot;, vjust=3.5, hjust=0.5, position = position_stack())#这里的position要与geom_bar()里面的保持一致，各种参数多调整才能效果最佳 下次将重点讲解如何添加误差棒、显著性标记、坐标轴标题、图标题以及部分小技巧等等]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>R&amp;ggplot2&amp;visualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R语言学习笔记之聚类分析]]></title>
    <url>%2F2017%2F06%2F25%2FR%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[使用k-means聚类所需的包： factoextra cluster #加载包12library(factoextra)library(cluster) #数据准备使用内置的R数据集USArrests123456#load the datasetdata(&quot;USArrests&quot;)#remove any missing value (i.e, NA values for not available)#That might be present in the dataUSArrests &lt;- na.omit(USArrests)#view the first 6 rows of the datahead(USArrests, n=6) 在此数据集中，列是变量，行是观测值在聚类之前我们可以先进行一些必要的数据检查即数据描述性统计，如平均值、标准差等1234567desc_stats &lt;- data.frame( Min=apply(USArrests, 2, min),#minimumMed=apply(USArrests, 2, median),#median Mean=apply(USArrests, 2, mean),#mean SD=apply(USArrests, 2, sd),#Standard deviation Max=apply(USArrests, 2, max)#maximum)desc_stats &lt;- round(desc_stats, 1)#保留小数点后一位head(desc_stats) 变量有很大的方差及均值时需进行标准化1df &lt;- scale(USArrests) #数据集群性评估使用get_clust_tendency()计算Hopkins统计量123res &lt;- get_clust_tendency(df, 40, graph = TRUE)res$hopkins_stat## [1] 0.3440875 12#Visualize the dissimilarity matrixres$plot Hopkins统计量的值&lt;0.5，表明数据是高度可聚合的。另外，从图中也可以看出数据可聚合。 #估计聚合簇数由于k均值聚类需要指定要生成的聚类数量，因此我们将使用函数clusGap()来计算用于估计最优聚类数。函数fviz_gap_stat()用于可视化。12345set.seed(123)## Compute the gap statisticgap_stat &lt;- clusGap(df, FUN = kmeans, nstart = 25, K.max = 10, B = 500) # Plot the resultfviz_gap_stat(gap_stat) 图中显示最佳为聚成四类（k=4） #进行聚类123set.seed(123)km.res &lt;- kmeans(df, 4, nstart = 25)head(km.res$cluster, 20) 12# Visualize clusters using factoextrafviz_cluster(km.res, USArrests) #检查cluster silhouette图 Recall that the silhouette measures (SiSi) how similar an object ii is to the the other objects in its own cluster versus those in the neighbor cluster. SiSi values range from 1 to - 1: A value of SiSi close to 1 indicates that the object is well clustered. In the other words, the object ii is similar to the other objects in its group. A value of SiSi close to -1 indicates that the object is poorly clustered, and that assignment to some other cluster would probably improve the overall results.123sil &lt;- silhouette(km.res$cluster, dist(df))rownames(sil) &lt;- rownames(USArrests)head(sil[, 1:3]) 12#Visualize fviz_silhouette(sil) 图中可以看出有负值，可以通过函数silhouette()确定是哪个观测值1234neg_sil_index &lt;- which(sil[, &quot;sil_width&quot;] &lt; 0)sil[neg_sil_index, , drop = FALSE]## cluster neighbor sil_width## Missouri 3 2 -0.07318144 #eclust():增强的聚类分析 与其他聚类分析包相比，eclust()有以下优点： 简化了聚类分析的工作流程 可以用于计算层次聚类和分区聚类 eclust()自动计算最佳聚类簇数。 自动提供Silhouette plot 可以结合ggplot2绘制优美的图形 #使用eclust()的K均值聚类12# Compute k-meansres.km &lt;- eclust(df, &quot;kmeans&quot;) 12# Gap statistic plotfviz_gap_stat(res.km$gap_stat) 123456# Silhouette plotfviz_silhouette(res.km)## cluster size ave.sil.width## 1 1 13 0.31## 2 2 29 0.38## 3 3 8 0.39 #使用eclust（）的层次聚类123# Enhanced hierarchical clusteringres.hc &lt;- eclust(df, &quot;hclust&quot;) # compute hclustfviz_dend(res.hc, rect = TRUE) # dendrogam 123456#下面的R代码生成Silhouette plot和分层聚类散点图。fviz_silhouette(res.hc) # silhouette plot## cluster size ave.sil.width## 1 1 19 0.26## 2 2 19 0.28## 3 3 12 0.43 1fviz_cluster(res.hc) # scatter plot #Infos This analysis has been performed using R software (R version 3.3.2)]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>R&amp;Cluster analysis&amp;visualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ggplot2学习笔记系列之主题（theme）设置]]></title>
    <url>%2F2017%2F06%2F25%2Fggplot2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%BB%E9%A2%98%EF%BC%88theme%EF%BC%89%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[上次提了下theme(),本文将专门讲解一下。凡是与数据无关的图形设置可以归为主题类，ggplot2中主题设置十分多，根本不可能讲解完，只能稍微讲点皮毛，灵活运用才是关键，本文只是总体上略作介绍。正如R语言大神Hadley Wickham所讲的，ggplot2只是提供了一个平台，可以根据自己的需要无限创造。理论上来讲，只要能想到的图形，ggplot2都能实现。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253library(ggplot2)#我们先来看看ggplot2默认的主题设置函数theme_gray()的源代码theme_gray#函数名不加括号可获得函数源代码## function (base_size = 11, base_family = &quot;&quot;) ## &#123;## half_line &lt;- base_size/2## theme(line = element_line(colour = &quot;black&quot;, size = 0.5, linetype = 1, ## lineend = &quot;butt&quot;), rect = element_rect(fill = &quot;white&quot;, ## colour = &quot;black&quot;, size = 0.5, linetype = 1), text = element_text(family = base_family, ## face = &quot;plain&quot;, colour = &quot;black&quot;, size = base_size, lineheight = 0.9, ## hjust = 0.5, vjust = 0.5, angle = 0, margin = margin(), ## debug = FALSE), axis.line = element_blank(), axis.line.x = NULL, ## axis.line.y = NULL, axis.text = element_text(size = rel(0.8),## colour = &quot;grey30&quot;), axis.text.x = element_text(margin = margin(t = 0.8 * ## half_line/2), vjust = 1), axis.text.x.top = element_text(margin = margin(b = 0.8 * ## half_line/2), vjust = 0), axis.text.y = element_text(margin = margin(r = 0.8 * ## half_line/2), hjust = 1), axis.text.y.right = element_text(margin = margin(l = 0.8 * ## half_line/2), hjust = 0), axis.ticks = element_line(colour = &quot;grey20&quot;), ## axis.ticks.length = unit(half_line/2, &quot;pt&quot;), axis.title.x = element_text(margin = margin(t = half_line), ## vjust = 1), axis.title.x.top = element_text(margin = margin(b = half_line), ## vjust = 0), axis.title.y = element_text(angle = 90, ## margin = margin(r = half_line), vjust = 1), axis.title.y.right = element_text(angle = -90, ## margin = margin(l = half_line), vjust = 0), legend.background = element_rect(colour = NA), ## legend.spacing = unit(0.4, &quot;cm&quot;), legend.spacing.x = NULL, ## legend.spacing.y = NULL, legend.margin = margin(0.2, ## 0.2, 0.2, 0.2, &quot;cm&quot;), legend.key = element_rect(fill = &quot;grey95&quot;, ## colour = &quot;white&quot;), legend.key.size = unit(1.2, &quot;lines&quot;), ## legend.key.height = NULL, legend.key.width = NULL, legend.text = element_text(size = rel(0.8)), ## legend.text.align = NULL, legend.title = element_text(hjust = 0), ## legend.title.align = NULL, legend.position = &quot;right&quot;, ## legend.direction = NULL, legend.justification = &quot;center&quot;, ## legend.box = NULL, legend.box.margin = margin(0, 0, 0, ## 0, &quot;cm&quot;), legend.box.background = element_blank(),## legend.box.spacing = unit(0.4, &quot;cm&quot;), panel.background = element_rect(fill = &quot;grey92&quot;, ## colour = NA), panel.border = element_blank(), panel.grid.major = element_line(colour = &quot;white&quot;), ## panel.grid.minor = element_line(colour = &quot;white&quot;, size = 0.25), ## panel.spacing = unit(half_line, &quot;pt&quot;), panel.spacing.x = NULL, ## panel.spacing.y = NULL, panel.ontop = FALSE, strip.background = element_rect(fill = &quot;grey85&quot;, ## colour = NA), strip.text = element_text(colour = &quot;grey10&quot;, ## size = rel(0.8)), strip.text.x = element_text(margin = margin(t = half_line, ## b = half_line)), strip.text.y = element_text(angle = -90, ## margin = margin(l = half_line, r = half_line)), strip.placement = &quot;inside&quot;, ## strip.placement.x = NULL, strip.placement.y = NULL, strip.switch.pad.grid = unit(0.1, ## &quot;cm&quot;), strip.switch.pad.wrap = unit(0.1, &quot;cm&quot;), plot.background = element_rect(colour = &quot;white&quot;), ## plot.title = element_text(size = rel(1.2), hjust = 0, ## vjust = 1, margin = margin(b = half_line * 1.2)), ## plot.subtitle = element_text(size = rel(0.9), hjust = 0, ## vjust = 1, margin = margin(b = half_line * 0.9)),## plot.caption = element_text(size = rel(0.9), hjust = 1, ## vjust = 1, margin = margin(t = half_line * 0.9)),## plot.margin = margin(half_line, half_line, half_line, ## half_line), complete = TRUE)## &#125;## &lt;environment: namespace:ggplot2&gt; 可以看出，源代码主要是theme()函数，设置也很简单：theme(..., complete = FALSE),但是其内含的参数则十分多。 几乎所有元素在theme()里都使用element_line，element_rect，element_text和element_blank函数设置. 下面就举例稍微讲解一下12345#利用数据集mtcars演示head(mtcars)#先创建p图层p&lt;- ggplot(data=mtcars, aes(x=wt, y=mpg))+geom_point(aes(color=factor(cyl)))#先试试图例修改p+theme(legend.position = &quot;none&quot;)#无图例 1p+theme(legend.position = &quot;bottom&quot;)#图例在底部 12#也可以自定义p+theme(legend.position = c(0.5, 0.7)) 12#为图例加边界p+theme(legend.background = element_rect(color=&quot;red&quot;)) 12#或者为图例中的每个元素进行设置，如加边界p+theme(legend.key =element_rect(color=&quot;red&quot;)) 12#进行填充p+theme(legend.key = element_rect(fill=&quot;yellow&quot;)) 12#图例内容字体大小、颜色、角度等设置p+theme(legend.text = element_text(size=25, color=&quot;darkred&quot;, angle=45)) 12#为图例标题设置字体、颜色、大小等p+theme(legend.title = element_text(face=&quot;italic&quot;, size=25, color=&quot;red&quot;)) 接下来是坐标以及网格等的自定义12#修改背景颜色p+theme(panel.background = element_rect(fill=&quot;black&quot;)) 12#修改边界线类型、颜色p+theme(panel.border = element_rect(linetype = &quot;dashed&quot;, color=&quot;red&quot;)) 1#修改网格线p+theme(panel.grid.major = element_line(color=&quot;blue&quot;, size= 3)) 1p+theme(panel.grid.minor = element_line(linetype = &quot;dotted&quot;, color=&quot;red&quot;)) 还可以修改x、y轴等，这里懒得讲了，有兴趣的可以自己捣鼓捣鼓 了解theme之后就可以自己定义自己的主题，以后作图就直接像格式刷一样就行123456789101112131415161718192021#下面是我比较常用的主题，画图时刷一下就行了windowsFonts(CA=windowsFont(&quot;Calibri&quot;))mytheme &lt;- theme_bw()+theme(legend.position = &apos;top&apos;, panel.border = element_blank(), panel.grid.major = element_line(linetype = &apos;dashed&apos;), panel.grid.minor = element_blank(), legend.text = element_text(size=9,color=&apos;#003087&apos;,family = &quot;CA&quot;), plot.title = element_text(size=15,color=&quot;#003087&quot;,family = &quot;CA&quot;), legend.key = element_blank(), axis.text = element_text(size=10,color=&apos;#003087&apos;,family = &quot;CA&quot;), strip.text = element_text(size=12,color=&quot;#EF0808&quot;,family = &quot;CA&quot;), strip.background = element_blank())pie_theme &lt;- mytheme+theme(axis.text = element_blank(), axis.ticks = element_blank(), axis.title = element_blank(), panel.grid.major = element_blank())myline_blue &lt;- geom_line(color=&quot;#085A9C&quot;, size=2)myline_red &lt;- geom_line(color=&quot;#EF0808&quot;,size=2)myarea &lt;- geom_area(color=NA,fill=&quot;#003087&quot;,alpha=0.2)mypoint &lt;- geom_point(size=3,shape=21,color=&quot;#003087&quot;,fill=&quot;white&quot;)mybar &lt;- geom_bar(fill=&quot;#0C8DC4&quot;,stat = &quot;identity&quot;)mycolor_3 &lt;- scale_fill_manual(values = c(&quot;#085A9C&quot;,&quot;#EF0808&quot;,&quot;#526373&quot;))mycolor_7 &lt;- scale_fill_manual(values=c (&quot;#085A9C&quot;,&quot;#EF0808&quot;,&quot;#526373&quot;,&quot;#FFFFE7&quot;,&quot;#FF9418&quot;,&quot;#219431&quot;,&quot;#9C52AD&quot;))mycolor_line_7 &lt;- scale_color_manual(values=c (&quot;#085A9C&quot;,&quot;#EF0808&quot;,&quot;#526373&quot;,&quot;#FFFFE7&quot;,&quot;#FF9418&quot;,&quot;#219431&quot;,&quot;#9C52AD&quot;)) 1234567891011121314151617181920#可以来刷一刷#随便建个数据集x &lt;-rep(1:5, each = 3)y &lt;-rep(c(&apos;A&apos;,&apos;B&apos;,&apos;C&apos;),times = 5)set.seed(1111)z &lt;-round(runif(min = 10, max = 30, n = 15))df &lt;-data.frame(x = x, y = y, z = z)head(df)## x y z## 1 1 A 19## 2 1 B 18## 3 1 C 28## 4 2 A 13## 5 2 B 25## 6 2 C 30#柱形图(p1 &lt;- ggplot(data=df, aes(x=factor(x), y=z, fill=y))+geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;)+ggtitle(&quot;自定义主题theme并应用实践&quot;))+xlab(&quot;随便定义了个x&quot;)+ylab(&quot;随机数&quot;) 1p1+mytheme 1p1+mytheme+mycolor_7 还有线图、饼图等有兴趣的也可以自己刷一刷，你会发现ggplot2的魅力所在就是它拥有无穷的可能性。]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>R&amp;ggplot2&amp;visualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R语言可视化学习笔记之ggrepel包]]></title>
    <url>%2F2017%2F06%2F25%2FR%E8%AF%AD%E8%A8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bggrepel%E5%8C%85%2F</url>
    <content type="text"><![CDATA[当我们在图形中添加标签时，标签之间很容易相互重叠，包ggrepel就专门用来解决这个问题！ 首先我们来看看通过geom_text()添加标签时的情形：12345library(ggplot2)#使用数据集mtcars演示ggplot(mtcars)+ geom_point(aes(wt, mpg), color=&quot;red&quot;)+ geom_text(aes(wt, mpg, label=rownames(mtcars)))+ theme_classic(base_size = 16) 可以看到可视化效果不是很好。接下来看看包ggrepel的效果。geom_text_repel()是基于geom_text()12345library(ggrepel)set.seed(42)ggplot(mtcars)+ geom_point(aes(wt, mpg), color=&quot;red&quot;)+ geom_text_repel(aes(wt, mpg, label=rownames(mtcars)))+theme_classic(base_size = 16) #geom_label_repel()geom_label_repel()是基于geom_label(),它将标签置于一个小方框中123456set.seed(42)ggplot(mtcars)+ geom_point(aes(wt, mpg), color=&quot;grey&quot;, size=5)+geom_label_repel(aes(wt, mpg, fill=factor(cyl), label=rownames(mtcars)), fontface=&quot;bold&quot;, color=&quot;white&quot;, box.padding=unit(0.35, &quot;lines&quot;), point.padding=unit(0.5, &quot;lines&quot;), segment.colour = &quot;grey50&quot;)+ theme_classic(base_size = 16) #参数大部分geom_text()的参数都适用于geom_text_repel(),除了以下几个： hjust vjust position check_overlap ggrepel包为geom_text_repel()与geom_label_repel()提供了特有的参数设置： segment.color:连接点与标签的线段的颜色 segment.size:线段的粗细 segment.alpha:线段的透明度 box.padding:文本框周边填充 point.padding:点周围填充 arrow:grid:arrow提供的箭头 force:强制性将重叠文本散开 max.oter:最大迭代次数 nudge_x/y:标签开始位置在坐标轴的移动距离 direction:允许标签的方向，x、y or both 下面举个栗子来详细了解这些参数的图形效果12345678910111213set.seed(42)ggplot(mtcars)+ geom_point(aes(wt, mpg, color=factor(cyl)), size=3)+geom_text_repel(aes(wt, mpg, color=factor(cyl), label=rownames(mtcars), angle=ifelse(mtcars$cyl==4, 90, 0)), size=4, family=&quot;Times&quot;, fontface=&quot;bold&quot;, box.padding=unit(0.5, &quot;lines&quot;), point.padding=unit(1.6, &quot;lines&quot;), segment.color = &quot;#cccccc&quot;, segment.size = 0.5, arrow = arrow(length=unit(0.01, &quot;npc&quot;)),force = 1, max.iter = 3e3, nudge_x = ifelse(mtcars$cyl==6, 2, 0), nudge_y = ifelse(mtcars$cyl==6, 9, 0))+ scale_color_discrete(name=&quot;cyl&quot;)+ scale_x_continuous(expand = c(0.5, 0))+ scale_y_continuous(expand = c(0.25, 0))+ theme_classic(base_size = 16) 也可以通过设置参数point.padding=NA不对点进行repel12345set.seed(42)mtcars$label &lt;- rownames(mtcars)ggplot(mtcars, aes(wt, mpg, label=label))+ geom_point(color=&quot;red&quot;)+ geom_text_repel(point.padding = NA)+theme_classic(base_size = 16) 通过赋值某些label空字符“”来隐藏。1234567set.seed(42)mtcars$label &lt;- rownames(mtcars)mtcars$label[1:15] &lt;- &quot;&quot;ggplot(mtcars, aes(wt, mpg))+ geom_point(aes(color=factor(cyl)), size=2)+geom_text_repel(aes(color=factor(cyl), size=hp, label=label), point.padding = unit(0.25, &quot;lines&quot;), box.padding = unit(0.25, &quot;lines&quot;), nudge_y = 0.1)+ theme_classic(base_size = 16) #将标签控制在特定区域通过设置参数xlim和ylim来限制label的位置1234567891011set.seed(42)data &lt;- mtcarsmu &lt;- mean(data$wt)left &lt;- data[data$wt &lt;mu, ]right &lt;- data[data$wt&gt;=mu, ]ggplot()+ geom_vline(xintercept = mu)+ geom_point(aes(wt, mpg), data=data)+ geom_text_repel(data=left, aes(wt, mpg, label=rownames(left), color=&quot;Left half&quot;), xlim=c(NA, mu))+ geom_text_repel(data=right, aes(wt, mpg, label=rownames(right), color=&quot;Rigth half&quot;), xlim=c(mu, NA))+ theme_classic(base_size = 16) 通过控制参数direction来决定label是左右移动还是上下移动， 默认是both123456set.seed(42)#direction=&quot;x&quot; 左右移动ggplot(mtcars)+ geom_point(aes(wt, mpg), color=&quot;red&quot;)+ geom_text_repel(aes(wt, mpg, label=rownames(mtcars)), direction=&quot;x&quot;)+ theme_classic(base_size = 16)+xlim(1, 6) 12345#direction=&quot;x&quot; 上下移动ggplot(mtcars)+ geom_point(aes(wt, mpg), color=&quot;red&quot;)+ geom_text_repel(aes(wt, mpg, label=rownames(mtcars)), direction=&quot;y&quot;)+ theme_classic(base_size = 16)+xlim(1, 6) #线图123456789set.seed(42)ggplot(Orange, aes(age, circumference, color=Tree))+ geom_line()+ coord_cartesian(xlim=c(min(Orange$age), max(Orange$age)+90))+ geom_text_repel(data=subset(Orange, age==max(age)), aes(label=paste(&quot;Tree&quot;, Tree)),size=6, nudge_x = 45, segment.color = NA)+ theme_classic(base_size = 16)+ theme(legend.position = &quot;none&quot;)+ labs(title=&quot;Orange Trees&quot;, x=&quot;Age(days)&quot;, y=&quot;Circumference(mm)&quot;) #SessionInfo123456789101112131415161718192021222324252627sessionInfo()## R version 3.4.0 (2017-04-21)## Platform: x86_64-w64-mingw32/x64 (64-bit)## Running under: Windows 8.1 x64 (build 9600)## ## Matrix products: default## ## locale:## [1] LC_COLLATE=Chinese (Simplified)_China.936 ## [2] LC_CTYPE=Chinese (Simplified)_China.936 ## [3] LC_MONETARY=Chinese (Simplified)_China.936## [4] LC_NUMERIC=C ## [5] LC_TIME=Chinese (Simplified)_China.936 ## ## attached base packages:## [1] stats graphics grDevices utils datasets methods base #### other attached packages:## [1] ggrepel_0.6.5 ggplot2_2.2.1## ## loaded via a namespace (and not attached):## [1] Rcpp_0.12.11 digest_0.6.12 rprojroot_1.2 plyr_1.8.4 ## [5] grid_3.4.0 gtable_0.2.0 backports_1.1.0 magrittr_1.5 ## [9] evaluate_0.10 scales_0.4.1 rlang_0.1.1 stringi_1.1.5 ## [13] lazyeval_0.2.0 rmarkdown_1.5 labeling_0.3 tools_3.4.0 ## [17] stringr_1.2.0 munsell_0.4.3 yaml_2.1.14 compiler_3.4.0 ## [21] colorspace_1.3-2 htmltools_0.3.6 knitr_1.16 tibble_1.3.3 联系方式： wechat: yt056410 Email: tyan@zju.edu.cn QQ: 1051927088 GitHub: https://github.com/YTLogos 简书: http://www.jianshu.com/u/bd001545cf0b 博客: https://ytlogos.github.io/ 个人简介：严涛 浙江大学作物遗传育种在读研究生（生物信息学方向） 伪码农，R语言爱好者，爱开源]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>R&amp;ggrepel&amp;visualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R语言可视化学习笔记之添加p-value和显著性标记]]></title>
    <url>%2F2017%2F06%2F25%2FR%E8%AF%AD%E8%A8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B7%BB%E5%8A%A0p-value%E5%92%8C%E6%98%BE%E8%91%97%E6%80%A7%E6%A0%87%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[上篇文章中提了一下如何通过ggpubr包为ggplot图添加p-value以及显著性标记,本文将详细介绍。利用数据集ToothGrowth进行演示12345#先加载包library(ggpubr)#加载数据集ToothGrowthdata(&quot;ToothGrowth&quot;)head(ToothGrowth) 1234567## len supp dose## 1 4.2 VC 0.5## 2 11.5 VC 0.5## 3 7.3 VC 0.5## 4 5.8 VC 0.5## 5 6.4 VC 0.5## 6 10.0 VC 0.5 #比较方法R中常用的比较方法主要有下面几种： 方法 R函数 描述 T-test t.test() 比较两组(参数) Wilcoxon test wilcox.test() 比较两组(非参数) ANOVA aov()或anova() 比较多组(参数) Kruskal-Wallis kruskal.test() 比较多组(非参数) 各种比较方法后续有时间一一讲解。 #添加p-value主要利用ggpubr包中的两个函数： compare_means():可以进行一组或多组间的比较 stat_compare_mean():自动添加p-value、显著性标记到ggplot图中 ##compare_means()函数该函数主要用用法如下：12compare_means(formula, data, method = &quot;wilcox.test&quot;, paired = FALSE, group.by = NULL, ref.group = NULL, ...) 注释： formula:形如x~group，其中x是数值型变量，group是因子，可以是一个或者多个 data：数据集 method:比较的方法，默认为&quot;wilcox.test&quot;, 其他可选方法为：&quot;t.test&quot;、&quot;anova&quot;、&quot;kruskal.test&quot; paired:是否要进行paired test(TRUE or FALSE) group_by: 比较时是否要进行分组 ref.group: 是否需要指定参考组 ##stat_compare_means()函数主要用法：12stat_compare_means(mapping = NULL, comparisons = NULL hide.ns = FALSE, label = NULL, label.x = NULL, label.y = NULL, ...) 注释： mapping:由aes()创建的一套美学映射 comparisons:指定需要进行比较以及添加p-value、显著性标记的组 hide.ns:是否要显示显著性标记ns label:显著性标记的类型，可选项为：p.signif(显著性标记)、p.format(显示p-value) label.x、label.y:显著性标签调整 …:其他参数 ##比较独立的两组1compare_means(len~supp, data=ToothGrowth) 结果解释： .y:测试中使用的y变量 p:p-value p.adj:调整后的p-value。默认为p.adjust.method=&quot;holm&quot; p.format:四舍五入后的p-value p.signif:显著性水平 method:用于统计检验的方法##绘制箱线图12p &lt;- ggboxplot(ToothGrowth, x=&quot;supp&quot;, y=&quot;len&quot;, color = &quot;supp&quot;, palette = &quot;jco&quot;, add = &quot;jitter&quot;)#添加p-valuep+stat_compare_means() 12#使用其他统计检验方法p+stat_compare_means(method = &quot;t.test&quot;) 上述显著性标记可以通过label.x、label.y、hjust及vjust来调整显著性标记可以通过aes()映射来更改： aes(label=..p.format..)或aes(lebel=paste0(&quot;p=&quot;,..p.format..)):只显示p-value，不显示统计检验方法 aes(label=..p.signif..):仅显示显著性水平 aes(label=paste0(..method..,&quot;\n&quot;, &quot;p=&quot;,..p.format..)):p-value与显著性水平分行显示 举个栗子：1p+stat_compare_means(aes(label=..p.signif..), label.x = 1.5, label.y = 40) 也可以将标签指定为字符向量，不要映射，只需将p.signif两端的..去掉即可1p+stat_compare_means(label = &quot;p.signif&quot;, label.x = 1.5, label.y = 40) ##比较两个paired sample1compare_means(len~supp, data=ToothGrowth, paired = TRUE) ##利用ggpaired()进行可视化12ggpaired(ToothGrowth, x=&quot;supp&quot;, y=&quot;len&quot;, color = &quot;supp&quot;, line.color = &quot;gray&quot;, line.size = 0.4, palette = &quot;jco&quot;)+ stat_compare_means(paired = TRUE) ##多组比较Global test1compare_means(len~dose, data=ToothGrowth, method = &quot;anova&quot;) #可视化12ggboxplot(ToothGrowth, x=&quot;dose&quot;, y=&quot;len&quot;, color = &quot;dose&quot;, palette = &quot;jco&quot;)+stat_compare_means() 123#使用其他的方法ggboxplot(ToothGrowth, x=&quot;dose&quot;, y=&quot;len&quot;, color = &quot;dose&quot;, palette = &quot;jco&quot;)+ stat_compare_means(method = &quot;anova&quot;) Pairwise comparisons:如果分组变量中包含两个以上的水平，那么会自动进行pairwise test,默认方法为”wilcox.test” 1compare_means(len~dose, data=ToothGrowth) 12345#可以指定比较哪些组my_comparisons &lt;- list(c(&quot;0.5&quot;, &quot;1&quot;), c(&quot;1&quot;, &quot;2&quot;), c(&quot;0.5&quot;, &quot;2&quot;))ggboxplot(ToothGrowth, x=&quot;dose&quot;, y=&quot;len&quot;, color = &quot;dose&quot;,palette = &quot;jco&quot;)+stat_compare_means(comparisons=my_comparisons)+ # Add pairwise comparisons p-value stat_compare_means(label.y = 50) # Add global p-value 可以通过修改参数label.y来更改标签的位置123ggboxplot(ToothGrowth, x=&quot;dose&quot;, y=&quot;len&quot;, color = &quot;dose&quot;,palette = &quot;jco&quot;)+stat_compare_means(comparisons=my_comparisons, label.y = c(29, 35, 40))+ # Add pairwise comparisons p-value stat_compare_means(label.y = 45) # Add global p-value 至于通过添加线条来连接比较的两组，这一功能已由包ggsignif实现123##设定参考组compare_means(len~dose, data=ToothGrowth, ref.group = &quot;0.5&quot;, #以dose=0.5组为参考组 method = &quot;t.test&quot; ) 1234#可视化ggboxplot(ToothGrowth, x=&quot;dose&quot;, y=&quot;len&quot;, color = &quot;dose&quot;, palette = &quot;jco&quot;)+ stat_compare_means(method = &quot;anova&quot;, label.y = 40)+ # Add global p-valuestat_compare_means(label = &quot;p.signif&quot;, method = &quot;t.test&quot;, ref.group = &quot;0.5&quot;) # Pairwise comparison against reference 参考组也可以设置为.all.即所有的平均值1compare_means(len~dose, data=ToothGrowth, ref.group = &quot;.all.&quot;, method = &quot;t.test&quot;) 12345#可视化ggboxplot(ToothGrowth, x=&quot;dose&quot;, y=&quot;len&quot;, color = &quot;dose&quot;, palette = &quot;jco&quot;)+stat_compare_means(method = &quot;anova&quot;, label.y = 40)+# Add global p-valuestat_compare_means(label = &quot;p.signif&quot;, method = &quot;t.test&quot;, ref.group = &quot;.all.&quot;)#Pairwise comparison against all 接下来利用survminer包中的数据集myeloma来讲解一下为什么有时候我们需要将ref.group设置为.all.123library(survminer)#没安装的先安装再加载data(&quot;myeloma&quot;)head(myeloma) 我们将根据患者的分组来绘制DEPDC1基因的表达谱，看不同组之间是否存在显著性的差异，我们可以在7组之间进行比较，但是这样的话组间比较的组合就太多了，因此我们可以将7组中每一组与全部平均值进行比较，看看DEPDC1基因在不同的组中是否过表达还是低表达。 1compare_means(DEPDC1~molecular_group, data = myeloma, ref.group = &quot;.all.&quot;, method = &quot;t.test&quot;) 1234567#可视化DEPDC1基因表达谱ggboxplot(myeloma, x=&quot;molecular_group&quot;, y=&quot;DEPDC1&quot;, color = &quot;molecular_group&quot;, add = &quot;jitter&quot;, legend=&quot;none&quot;)+ rotate_x_text(angle = 45)+ geom_hline(yintercept = mean(myeloma$DEPDC1), linetype=2)+# Add horizontal line at base mean stat_compare_means(method = &quot;anova&quot;, label.y = 1600)+ # Add global annova p-value stat_compare_means(label = &quot;p.signif&quot;, method = &quot;t.test&quot;, ref.group = &quot;.all.&quot;)# Pairwise comparison against all 从图中可以看出，DEPDC1基因在Proliferation组中显著性地过表达，而在Hyperdiploid和Low bone disease显著性地低表达 我们也可以将非显著性标记ns去掉，只需要将参数hide.ns=TRUE123456ggboxplot(myeloma, x=&quot;molecular_group&quot;, y=&quot;DEPDC1&quot;, color = &quot;molecular_group&quot;, add = &quot;jitter&quot;, legend=&quot;none&quot;)+rotate_x_text(angle = 45)+ geom_hline(yintercept = mean(myeloma$DEPDC1), linetype=2)+# Add horizontal line at base mean stat_compare_means(method = &quot;anova&quot;, label.y = 1600)+ # Add global annova p-value stat_compare_means(label = &quot;p.signif&quot;, method = &quot;t.test&quot;, ref.group = &quot;.all.&quot;, hide.ns = TRUE)# Pairwise comparison against all ##多个分组变量按另一个变量进行分组之后进行统计检验，比如按变量dose进行分组：1compare_means(len~supp, data=ToothGrowth, group.by = &quot;dose&quot;) 12345#可视化p &lt;- ggboxplot(ToothGrowth, x=&quot;supp&quot;, y=&quot;len&quot;, color = &quot;supp&quot;, palette = &quot;jco&quot;, add = &quot;jitter&quot;, facet.by = &quot;dose&quot;, short.panel.labs = FALSE)#按dose进行分面#label只绘制p-valuep+stat_compare_means(label = &quot;p.format&quot;) 12#label绘制显著性水平p+stat_compare_means(label = &quot;p.signif&quot;, label.x = 1.5) 1234#将所有箱线图绘制在一个panel中p &lt;- ggboxplot(ToothGrowth, x=&quot;dose&quot;, y=&quot;len&quot;, color = &quot;supp&quot;, palette = &quot;jco&quot;, add = &quot;jitter&quot;)p+stat_compare_means(aes(group=supp)) 12#只显示p-valuep+stat_compare_means(aes(group=supp), label = &quot;p.format&quot;) 12#显示显著性水平p+stat_compare_means(aes(group=supp), label = &quot;p.signif&quot;) 12进行paired sample检验compare_means(len~supp, data=ToothGrowth, group.by = &quot;dose&quot;, paired = TRUE) 123456#可视化p &lt;- ggpaired(ToothGrowth, x=&quot;supp&quot;, y=&quot;len&quot;, color = &quot;supp&quot;, palette = &quot;jco&quot;, line.color=&quot;gray&quot;, line.size=0.4, facet.by = &quot;dose&quot;, short.panel.labs = FALSE)#按dose分面#只显示p-valuep+stat_compare_means(label = &quot;p.format&quot;, paired = TRUE) #其他图形 ##条形图与线图（一个分组变量）1234#有误差棒的条形图，实际上我以前的文章里有纯粹用ggplot2实现ggbarplot(ToothGrowth, x=&quot;dose&quot;, y=&quot;len&quot;, add = &quot;mean_se&quot;)+ stat_compare_means()+ stat_compare_means(ref.group = &quot;0.5&quot;, label = &quot;p.signif&quot;, label.y = c(22, 29)) 1234#有误差棒的线图ggline(ToothGrowth, x=&quot;dose&quot;, y=&quot;len&quot;, add = &quot;mean_se&quot;)+stat_compare_means()+ stat_compare_means(ref.group = &quot;0.5&quot;, label = &quot;p.signif&quot;, label.y = c(22, 29)) ##条形图与线图（两个分组变量）123ggbarplot(ToothGrowth, x=&quot;dose&quot;, y=&quot;len&quot;, add = &quot;mean_se&quot;, color = &quot;supp&quot;, palette = &quot;jco&quot;, position = position_dodge(0.8))+ stat_compare_means(aes(group=supp), label = &quot;p.signif&quot;, label.y = 29) 123ggline(ToothGrowth, x=&quot;dose&quot;, y=&quot;len&quot;, add = &quot;mean_se&quot;, color = &quot;supp&quot;, palette = &quot;jco&quot;)+ stat_compare_means(aes(group=supp), label = &quot;p.signif&quot;, label.y = c(16, 25, 29)) #Sessioninfo1234567891011121314151617181920212223242526272829303132333435363738sessionInfo()## R version 3.4.0 (2017-04-21)## Platform: x86_64-w64-mingw32/x64 (64-bit)## Running under: Windows 8.1 x64 (build 9600)## ## Matrix products: default## ## locale:## [1] LC_COLLATE=Chinese (Simplified)_China.936 ## [2] LC_CTYPE=Chinese (Simplified)_China.936 ## [3] LC_MONETARY=Chinese (Simplified)_China.936## [4] LC_NUMERIC=C ## [5] LC_TIME=Chinese (Simplified)_China.936 ## ## attached base packages:## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages:## [1] survminer_0.4.0 ggpubr_0.1.3 magrittr_1.5 ggplot2_2.2.1 ## ## loaded via a namespace (and not attached):## [1] Rcpp_0.12.11 compiler_3.4.0 plyr_1.8.4## [4] tools_3.4.0 digest_0.6.12 evaluate_0.10 ## [7] tibble_1.3.3 gtable_0.2.0 nlme_3.1-131 ## [10] lattice_0.20-35 rlang_0.1.1 Matrix_1.2-10 ## [13] psych_1.7.5 ggsci_2.4 DBI_0.6-1 ## [16] cmprsk_2.2-7 yaml_2.1.14 parallel_3.4.0 ## [19] gridExtra_2.2.1 dplyr_0.5.0 stringr_1.2.0 ## [22] knitr_1.16 survMisc_0.5.4 rprojroot_1.2 ## [25] grid_3.4.0 data.table_1.10.4 KMsurv_0.1-5 ## [28] R6_2.2.1 km.ci_0.5-2 survival_2.41-3 ## [31] foreign_0.8-68 rmarkdown_1.5 reshape2_1.4.2 ## [34] tidyr_0.6.3 purrr_0.2.2.2 splines_3.4.0 ## [37] backports_1.1.0 scales_0.4.1 htmltools_0.3.6 ## [40] assertthat_0.2.0 mnormt_1.5-5 xtable_1.8-2 ## [43] colorspace_1.3-2 ggsignif_0.2.0 labeling_0.3 ## [46] stringi_1.1.5 lazyeval_0.2.0 munsell_0.4.3 ## [49] broom_0.4.2 zoo_1.8-0]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>R&amp;ggrepel&amp;visualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R语言可视化学习笔记之相关矩阵可视化包ggcorrplot]]></title>
    <url>%2F2017%2F06%2F25%2FR%E8%AF%AD%E8%A8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%9B%B8%E5%85%B3%E7%9F%A9%E9%98%B5%E5%8F%AF%E8%A7%86%E5%8C%96%E5%8C%85ggcorrplot%2F</url>
    <content type="text"><![CDATA[基于ggplot2包以及corrplot包的相关矩阵可视化包ggcorrplot，ggcorrplot包提供对相关矩阵重排序以及在相关图中展示显著性水平的方法，同时也能计算相关性p-value安装方法就不提了，不懂的可以浏览我以前的文章12345library(ggcorrplot)#计算相关矩阵(cor()计算结果不提供p-value)data(&quot;mtcars&quot;)corr &lt;- round(cor(mtcars), 1)head(corr[, 1:6]) 123#用ggcorrplot包提供的函数cor_pmat()p.mat &lt;- cor_pmat(mtcars)head(p.mat[, 1:4]) 可视化相关性矩阵1ggcorrplot(corr)#method默认为square 12#方法为circleggcorrplot(corr, method = &quot;circle&quot;) 12#重排矩阵，使用分等级聚类ggcorrplot(corr, hc.order = TRUE, outline.color = &quot;white&quot;) 12#控制矩阵形状ggcorrplot(corr, hc.order = TRUE, type = &quot;lower&quot;, outline.color = &quot;white&quot;)#下三角形 12#上三角形ggcorrplot(corr, hc.order = TRUE, type = &quot;upper&quot;, outline.color = &quot;white&quot;) 123#更改颜色以及主题ggcorrplot(corr, hc.order = TRUE, type = &quot;lower&quot;, outline.color = &quot;white&quot;, ggtheme = ggplot2::theme_gray, colors = c(&quot;#6D9EC1&quot;, &quot;white&quot;, &quot;#E46726&quot;)) 12#添加相关系数ggcorrplot(corr, hc.order = TRUE, type = &quot;lower&quot;, lab = TRUE) 12#增加显著性水平，不显著的话就不添加了ggcorrplot(corr, hc.order = TRUE, type = &quot;lower&quot;, p.mat = p.mat) 12#将不显著的色块设置成空白ggcorrplot(corr, p.mat = p.mat, hc.order=TRUE, type = &quot;lower&quot;, insig = &quot;blank&quot;)]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>R&amp;ggcorrplot&amp;visualization</tag>
      </tags>
  </entry>
</search>